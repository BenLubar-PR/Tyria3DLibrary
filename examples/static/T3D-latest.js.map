{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ParserUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","[object Object]","settings","_settings","_workerPool","_workerLoad","_handleCounter","_workQueue","_handleRegister","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","freeWorkerIndex","_getFreeWorkerIndex","_workNext","workerId","workData","shift","handle","_getNewHandle","postMessage","path","_id","selfWorkerId","worker","Worker","onmessage","message_event","answer","data","handleID","split","handleData","dxtType","imageWidth","imageHeight","error","terminate","indexOf","GW2File","FileTypes","getFileType","first4","readCString","type","ArchiveParser","PersistantStore","DataReader","MapFileList","_dataReader","_persistantStore","_file","undefined","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","_readFileType","scanResult","fileType","change","Math","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","getFileIndex","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","callback","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","loadFile","persistantData","metaData","_fileTypeCache","fileBuffer","min","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","event","onupgradeneeded","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","apply","args","console","warn","debug","LocalReader","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","numErrors","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","loadFileList","readFileListAsync","getMapListAsync","readMapListAsync","mapList","loadMapList","renderMapContentsAsync","renderers","logger","context","parseInt","mapFile","runAllRenderers","runRenderer","renderClass","assign","bind","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","return_context","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","THREE","constructor","prototype","getOutput","otherClass","inflatedData","fileId","rawData","uarr","Uint8Array","rawStrings","String","fromCharCode","subarray","rawString","join","loadTextureFile","imageHeigth","image","width","height","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","hazeColorAsInt","writeMat","mat","forEach","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","getHazeColor","environmentChunkData","hazes","dataGlobal","haze","farColor","parseLights","lights","ambientLight","lighting","backlightIntensity","backlightColor","hasLight","light","idx","dirLightData","color","Color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","lightDir","AmbientLight","ambientTotal","g","b","parseSkybox","parameterChunkData","skyElements","skyModeTex","texPathNE","texPathSW","texPathT","bounds","rect","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","create","getChunk","hazeColor","lastP","seed","meshes","renderModels","models","title","MeshNormalMaterial","DoubleSide","parseAllModels","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","round","animationFromGeomIndex","geometryIndex","geometries","animations","havokChunkData","renderMesh","propGeomIndex","l","model","pos","translate","rot","rotate","scale","mesh","parseHavokMesh","rotation","order","seedRandom","sin","clone","geom","Geometry","vertices","v","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","renderZoneModelsCB","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","concat","meshCache","textureCache","lastPct","renderIndex","pct","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","Group","addLevel","getMeshesForFilename","isCached","boundingSphere","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","renderCallback","getFileIdsAsync","fileIds","getIdsForProp","Utils","getFilesUsedByModel","propFileIds","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","TerrainShader","drawWater","wireframe","opacity","transparent","renderRect","parseNumChunks","terrainData","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","loadPagedImageCallback","infaltedBuffer","terrainTiles","pimgDS","pimgTableDataChunk","pimgData","mapRect","parameterData","maxAnisotropy","anisotropy","xChunks","yChunks","allMaterials","materials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","solidColor","matName","chunkTex","wrapS","RepeatWrapping","wrapT","stepChunk","cx","cy","water","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","materialFile","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","envOutput","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","getAttribute","heightMapArray","chunk","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","renderChunk","pagedImageId","pagedImage","terrainChunk","texture","renderZone","zone","zoneDefs","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","readVerts","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","zPos","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","raycaster","Raycaster","intersections","intersectObject","distance","modelArray","modelFilename","rotRangeX","zOffsets","layerFlags","rotRangeY","rotRangeZ","scaleRange","fadeRange","zoneChunkData","zones","zoneArray","zoneDefArray","stepZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","root","addr","setting","regex","RegExp","chunkDef","formats","defsIdx","defs","versions","getRootName","pop","match","definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","finalMaterial","dxChunk","grChunk","finalTextures","effect","techniques","passes","effects","samplerTextures","shaders","pixelShader","samplerIndex","samplerIdx","sampler","samplers","textureToken","texTokens","textureIndex","samplerTex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","hasOwnProperty","getArrayReader","structDef","maxCount","struct","arr_len","arr_ptr","readType","getRefArrayReader","ret_arr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","matFiles","fvfFormat","Position","Weights","Normal","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","matIdx","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","loadMeshFromModelFile","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","yPos","dz","cz","plane","overdraw","sharedMeshes","matFileName","ShaderChunk"],"mappings":"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","file":"T3D-latest.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MathUtils = require('../util/MathUtils');\n\n/**\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\n * @namespace ArchiveParser\n */\n\n/**\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\n */\nasync function readArchive(file){\n    let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\n    let mftData = parseMFTTable((await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds);\n    let {ds, len} = await getFilePart(file, mftData.mftIndexOffset, mftData.mftIndexSize);\n    let indexTable = parseMFTIndex(ds, len);\n\n    return {\n        archiveHeader: archiveHeader,\n        metaTable: mftData.table,\n        indexTable: indexTable\n    };\n}\n\n\n/**\n * The header of the archive.\n * @typedef {Object} ArchiveHeader\n * @property {number} version\n * @property {number} magic\n * @property {number} headerSize\n * @property {number} chunkSize\n * @property {number} crc\n * @property {number} mftOffset\n * @property {number} mftSize\n * @property {number} flags\n */\n\n/**\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\n * \n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\n */\nfunction parseANDatHeader(ds){\n    var header = {};\n\n    // Header parsing\n    header.version = ds.readUint8();\n    header.magic = ds.readString(3);\n    header.headerSize = ds.readUint32();\n    ds.seek(ds.position + 4); //Skip uint32\n    header.chunkSize = ds.readUint32();\n    header.crc = ds.readUint32();\n    ds.seek(ds.position + 4); //Skip uint32\n    header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    header.mftSize = ds.readUint32();\n    header.flags = ds.readUint32();\n    // End header parsing\n\n    //Check MAGIC\n    if(header.magic != \"AN\\u001A\"){\n        T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR, \"ANDat header is not valid\", header.magic);\n        return undefined;\n    }\n\n    T3D.Logger.log(\n        T3D.Logger.TYPE_DEBUG,\n        \"Loaded Main .dat header\"\n    );\n\n    return header;\n}\n\n/**\n * The array containing all the meta information concerning the contained files\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\n */\n\n/**\n *   Parse the main information table that contains the offset, size, compression flags and crc\n * \n * @memberof ArchiveParser\n * @param {Datastream}  ds\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\n *   Returns undefined if it couldn't parse the table\n */\nfunction parseMFTTable(ds){\n    // Parse the table header\n    var header = {};\n    header.magic = ds.readString(4);\n    ds.seek(ds.position + 8) //Skip uint64\n    header.nbOfEntries = ds.readUint32();\n    ds.seek(ds.position + 4 + 4); //Skip uint32 * 2\n\n    //check MAGIC\n    if(header.magic != \"Mft\\u001A\"){\n        T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR, \"MFTTable header is not valid\", header.magic);\n        return undefined;\n    }\n\n    //Where we put all the parsed data\n    //We don't pre-alloc anymore since not having the data aligned together procs too many\n    //cache misses during a fullscan\n    let fullTable = [];\n    \n    // Go through the table\n    for(let i=1; i<header.nbOfEntries; i++){\n        let item = {};\n        item['offset'] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n        item['size'] = ds.readUint32();\n        item['compressed'] = ds.readUint16();\n        ds.seek(ds.position + 4 + 2); //Skip uint16 + uint32\n        item['crc'] = ds.readUint32();\n        fullTable[i] = item;\n    }\n\n    T3D.Logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Loaded MFTTable\"\n\t);\n\n    return {\n        header: header, \n        table: fullTable, \n        //Register the MFTIndex table position and size\n        mftIndexOffset: fullTable[2].offset, \n        mftIndexSize: fullTable[2].size\n    };\n}\n\n\n/**\n * The array linking all the file indexes to their respective files\n * @typedef {Array<number>} IndexTable\n */\n\n/**\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of \n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n * \n * @memberof ArchiveParser\n * @param {DataStream} ds \n * @param {number} size\n * @returns {IndexTable}\n */\nfunction parseMFTIndex(ds, size){\n    let length = size / 8;\n\n    let indexTable = [];\n\n    for(let i=0; i<length; i++){\n        //Parse table\n        let id = ds.readUint32();\n        let mftIndex = ds.readUint32();\n        //Store the values\n        indexTable[id] = mftIndex;\n    }\n\n    T3D.Logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Finished indexing MFT\"\n\t);\n\n    return indexTable;\n}\n\n\n/**\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\n * \n * @memberof ArchiveParser\n * @param {File} file \n * @param {number} offset \n * @param {number} length \n * @returns {Promise<{ds: DataStream, len: number}>}\n */\nfunction getFilePart(file, offset, length){\n    return new Promise((resolve, reject) => {\n        let reader = new FileReader();\n\n        reader.onerror = reject;\n    \n        reader.onload = function(fileEvent){\n            var buffer = fileEvent.target.result;\n            var ds = new DataStream(buffer);\n                ds.endianness = DataStream.LITTLE_ENDIAN;\n            // Pass data stream and data length to callback function\n            resolve({ds: ds, len: length});\n        }\n        \n        // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\n        reader.readAsArrayBuffer(file.slice(offset, offset + length));\n    })\n}\n\nmodule.exports = {\n    readArchive: readArchive,\n    parseANDatHeader: parseANDatHeader,\n    parseMFTTable: parseMFTTable,\n    parseMFTIndex: parseMFTIndex,\n    getFilePart: getFilePart\n};","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Organized thread pool of extractors\n * @class DataReader\n */\nclass DataReader {\n    /**\n     * @constructor\n     * @param {Object} settings\n     * @param {number} settings.workersNb Amount of concurrent spawned workers\n     * @param {string} settings.workerPath Path to the worker script\n     */\n    constructor(settings){\n        this._settings = settings;\n        this._workerPool = [];\n        this._workerLoad = [];\n        \n        //Makes individual ids for file extraction\n        this._handleCounter = 0;\n\n        /** \n         * Work to be processed\n         * @private \n         * @type {[{buffer: ArrayBuffer, size: number, mftId: number, isImage: boolean, capLength: number, resolve: function, reject: function}]} \n         */\n        this._workQueue = [];\n\n        /**\n         * Work currently processed\n         * @private\n         * Entries : {mftId: number, workerId: number, resolve: resolve, reject: reject}\n         */\n        this._handleRegister = {};\n\n        for (let i = 0; i<settings.workersNb; i++){\n            this._startWorker(settings.workerPath);\n        }\n    }\n\n    /**\n     * @param {DataStream} ds \n     * @param {number} size \n     * @param {number} mftId\n     * @param {boolean} [isImage] Parses the output as a dxt texture\n     * @param {number} [capLength] Output size\n     * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>} \n     */\n    inflate(ds, size, mftId, isImage, capLength){\n        return new Promise((resolve, reject) => {\n            let arrayBuffer = ds.buffer;\n\n            //If no capLength then inflate the whole file\n            if(!capLength || capLength < 0){\n                capLength = 0;\n            }\n\n            //Buffer length size check\n            if(arrayBuffer.byteLength < 12){\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_WARNING,\n                    `not inflating, length is too short (${arrayBuffer.byteLength})`, mftId\n                );\n                reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\n                return;\n            }\n\n            //Register the data to work with\n            this._workQueue.push({\n                buffer: arrayBuffer, \n                size: size, \n                mftId: mftId, \n                isImage: isImage, \n                capLength: capLength, \n                resolve: resolve, \n                reject: reject\n            });\n\n            // Check if there is a free worker and ask it to start\n            const freeWorkerIndex = this._getFreeWorkerIndex();\n            if(freeWorkerIndex >= 0){\n                this._workNext(freeWorkerIndex);\n            } \n\n        });\n    }\n\n    /**\n     * Function used to give work to a worker\n     * @private\n     * @param {number} workerId\n     **/\n    _workNext(workerId){\n        const workData = this._workQueue.shift();\n\n        if(workData){\n            //Get a handleID\n            const handle = this._getNewHandle();\n\n            this._handleRegister[handle] = {\n                mftId: workData.mftId,\n                workerId: workerId,\n                resolve: workData.resolve,\n                reject: workData.reject\n            };\n\n            this._workerLoad[workerId] += 1;\n            this._workerPool[workerId].postMessage(\n                [handle, workData.buffer, workData.isImage===true, workData.capLength]\n            );\n        }\n\n    }\n\n    _getNewHandle() {\n        return this._handleCounter++;\n    }\n\n    // Initialization function for creating a new worker (thread)\n    // _id should only be used to restart a worker !\n    _startWorker(path, _id){\n        let worker = new Worker(path);\n        let selfWorkerId;\n        if(_id){\n            selfWorkerId = _id;\n            this._workerPool[selfWorkerId] = worker;\n            this._workerLoad[selfWorkerId] = 0;\n\n        } else {\n            selfWorkerId = this._workerPool.push(worker) - 1;\n            if(this._workerLoad.push(0) != selfWorkerId + 1) \n                throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n        }\n\n        //This\n        worker.onmessage = (message_event) => {\n            const answer = message_event.data;\n            let handleID;\n\n            // Remove load\n            this._workerLoad[selfWorkerId] -= 1;\n\n            // If error\n            if( typeof answer === 'string'){\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_WARNING,\n                    \"Inflater threw an error\", answer\n                );\n\n                //Parse the handle\n                handleID = answer.split(':')[0];\n\n                //Get handle owner informations and reject then cleanup\n                const handleData = this._handleRegister[handleID];\n                if(handleData){\n                    handleData.reject(`Error: ${answer}`);\n                    delete this._handleRegister[handleID];\n                }\n            } \n            else {\n                //Parse handle\n                handleID = answer[0];\n\n                const handleData = this._handleRegister[handleID];\n                // If handle is recognized: success\n                if(handleData){\n                    // Array buffer, dxtType, imageWidth, imageHeight\t\t\t\n                    handleData.resolve({buffer: answer[1], dxtType: answer[2], imageWidth: answer[3], imageHeight: answer[4]});\t\n                    \n                    //Cleanup\n                    delete this._handleRegister[handleID];\n                }\n                \n                // Unknown error\n                else {\n                    T3D.Logger.log(\n                        T3D.Logger.TYPE_ERROR,\n                        \"Inflater threw an error\", answer\n                    );\n                }\n            }\n\n            this._workNext(selfWorkerId);\n\n        };\n\n        //Handle errors, we assume worse case: it crashed and corrupted its memory\n        worker.onerror = (error) => {\n            //Get all handles sent to this worker and reject them\n            for(let handle in this._handleRegister){\n                if(this._handleRegister[handle].workerId === selfWorkerId){\n                    this._handleRegister[handle].reject(`Error: Worker crashed while processing ${handleData.mftId}`);\n                    delete this._handleRegister[handle];\n                }\n            }\n\n            //Clean and restart the worker\n            this._workerPool[selfWorkerId].terminate();\n            this._startWorker(this._settings.workerPath, selfWorkerId);\n\n        }\n\n    }\n\n    //Returns -1 if there are no free worker, or the index of a free worker\n    _getFreeWorkerIndex(){\n        return this._workerLoad.indexOf(0);\n    }\n\n}\n\nmodule.exports = DataReader;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require('../format/file/GW2File.js');\n\n/**\n * @namespace FileTypes\n */\n\nlet FileTypes = {};\n\n/**\n * Parse the beginning of a file to find its type\n * \n * @memberof FileTypes\n * @param {DataStream} ds \n * @return {number}\n */\nFileTypes.getFileType = function(ds){\n    let first4 = ds.readCString(4);\n\n    //Parse textures\n    switch(first4){\n        case 'ATEC':\n            return 'TEXTURE_ATEC';\n        case 'ATEP':\n            return 'TEXTURE_ATEP';\n        case 'ATET':\n            return 'TEXTURE_ATET';\n        case 'ATEU':\n            return 'TEXTURE_ATEU';\n        case 'ATEX':\n            return 'TEXTURE_ATEX';\n        case 'ATTX':\n            return 'TEXTURE_ATTX';\n    };\n\n    if (first4.indexOf(\"DDS\") === 0)\n        return 'TEXTURE_DDS';\n    \n    if (first4.indexOf(\"PNG\") === 1)\n        return 'TEXTURE_PNG';\n\n    if (first4.indexOf(\"RIFF\") === 0)\n        return 'TEXTURE_RIFF';\n\n    if (first4.indexOf(\"YUI\") === 0)\n        return 'TEXT_YUI';\n\n    // PackFiles\n    if (first4.indexOf(\"PF\") === 0){\n        let file = new GW2File(ds, 0, true);/// true for \"plz no load chunkz\"\n        return 'PF_' + file.header.type;\n    }\n    \n    // Binaries\n    if (first4.indexOf(\"MZ\") === 0)\n        return 'BINARIES';\n    \n    // Strings\n    if (first4.indexOf(\"strs\") === 0)\n        return 'STRINGS';\n\n    //Raw asnd chunk (without pack file)\n    if (first4.indexOf(\"asnd\") === 0)\n        return 'CHUNK_ASND';\n\n    // TODO: parse all datastream and if all bytes are valid unicode symbols then\n    // return TEXT_UNKNOWN;\n\n    // Unknown\n    return 'UNKNOWN';\n}\n\nmodule.exports = FileTypes;","/*\r\nCopyright © Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst ArchiveParser = require('./ArchiveParser');\r\nconst PersistantStore = require('./PersistantStore');\r\nconst DataReader = require('./DataReader');\r\nconst MapFileList = require('../MapFileList');\r\nconst FileTypes = require('./FileTypes');\r\n\r\n/**\r\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\r\n * LocalReader have been completely rewritten from scratch, \r\n * the API changed quite a lot between 1.0.4 and 1.1.0.\r\n * \r\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\r\n * - The constructor have __changed__.\r\n * - parseHeaderAsync have been __removed__.\r\n * - connectInflated have been __removed__.\r\n * - NaClListener have been __removed__.\r\n * - readANDatHeader have been __removed__.\r\n * - readMFTHeader have been __removed__.\r\n * - readMFTIndexFile have been __removed__.\r\n * - loadFileList is now __deprecated__.\r\n * - loadMapList is now __deprecated__.\r\n * - storeFileList have been __removed__.\r\n * - storeMapList have been __removed__.\r\n * - readFileListAsync is now __deprecated__.\r\n * - readMapListAsync is now __deprecated__.\r\n * - listFiles have been __removed__.\r\n * - getFileIndex have been slightly __changed__.\r\n * - loadTextureFile is now __deprecated__.\r\n * - loadFile have been __removed__.\r\n * - inflate have been __removed__.\r\n * - loadFilePart have been __removed__.\r\n * \r\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\r\n *   * workerPath: the path to the t3dtools worker script file.\r\n *   * workersNb: amount of threads spawned for decompression.\r\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\r\n */\r\nclass LocalReader {\r\n    constructor(settings) {\r\n        this._settings = settings;\r\n\r\n        /** \r\n         * @private\r\n         * @type {DataReader} \r\n         */\r\n        this._dataReader = new DataReader(settings);\r\n\r\n        /**\r\n         * @private\r\n         * @type {PersistantStore}\r\n         */\r\n        this._persistantStore;\r\n\r\n        /**\r\n         * @private\r\n         * @type {File} \r\n         */\r\n        this._file = undefined;\r\n\r\n        /** \r\n         * @private\r\n         * @type {Array<number>} \r\n         */\r\n        this._indexTable = [];\r\n\r\n        /** \r\n         * @private\r\n         * @type {Array<{offset: number, size: number, compressed: number, crc: number}>} \r\n         */\r\n        this._fileMetaTable = [];\r\n\r\n        if (settings.noIndexedDB !== false)\r\n            this._persistantStore = new PersistantStore();\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     *   Asynchronously loads the archive by parsing its file index and header.\r\n     *   \r\n     * @param {File} file \r\n     * @returns {Promise}\r\n     */\r\n    async openArchive(file) {\r\n        let { archiveHeader, metaTable, indexTable } = await ArchiveParser.readArchive(file);\r\n        this._fileMetaTable = metaTable;\r\n        this._indexTable = indexTable;\r\n        this._file = file;\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     *   Gets MFT index by baseId\r\n     * \r\n     * @param  {Number} baseId   A base Id\r\n     * @return {Number}          MFT index\r\n     */\r\n    getFileIndex(baseId) {\r\n        return this._indexTable[baseId];\r\n    }\r\n\r\n\r\n    /**\r\n     *   \"Meta\" informations to deal with files in the archive.\r\n     * @typedef     {Object}    FileMetaData\r\n     * @property    {number}    offset\r\n     * @property    {number}    size\r\n     * @property    {number}    compressed\r\n     * @property    {number}    crc\r\n     */\r\n\r\n    /**\r\n     *   Returns the metadata of a file stored in the archive\r\n     * \r\n     * @param {number} mftId Mft index of the file\r\n     * @returns {FileMetaData} Metadata informations\r\n     */\r\n    getFileMeta(mftId) {\r\n        return this._fileMetaTable[mftId];\r\n    }\r\n\r\n\r\n    /**\r\n     *   Fetch a file and uncompress it if needed / required.\r\n     * \r\n     * @param {number} mftId File's archive ID\r\n     * @param {boolean} [isImage] Try to read the data as a Dxt texture.\r\n     * @param {boolean} [raw] Force no decompression.\r\n     * @param {number} [fileLength] Slice the uncompressed file.\r\n     * @param {number} [extractLength] Slice the decompression.\r\n     * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\r\n     */\r\n    async readFile(mftId, isImage, raw, fileLength, extractLength) {\r\n        let buffer, dxtType, imageWidth, imageHeight;\r\n        let meta = this.getFileMeta(mftId);\r\n        if (!meta)\r\n            throw new Error(\"Unexistant file\");\r\n\r\n        //Slice up the data\r\n        let { ds, len } = await ArchiveParser.getFilePart(this._file, meta.offset, (fileLength) ? fileLength : meta.size);\r\n\r\n        //If needed we decompress, if not we keep raw\r\n        if (meta.compressed || (raw != false)){\r\n            let data;\r\n            await this._dataReader.inflate(ds, len, mftId, isImage, (extractLength) ? extractLength : 0)\r\n                .then((result) => { data = result})\r\n                .catch((error) => { data = {buffer: undefined, dxtType: undefined, imageWidth: undefined, imageHeight: undefined}})\r\n            return data;\r\n        }\r\n        else\r\n            return {buffer: ds.buffer};\r\n    }\r\n\r\n    /**\r\n     *   Scans asynchronously the types of all the files listed in the archive. \r\n     *   Uses persistant store to cache and speed up a rescan.\r\n     * \r\n     * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList \r\n     *   Way for platform not supporting indexDB to provide their own persistant storage.\r\n     * @returns {Promise<Array<FileItem>>}\r\n     */\r\n    async readFileList(oldFileList) {\r\n        let self = this;\r\n\r\n        let persistantList = (oldFileList) ? oldFileList : [];\r\n        let persistantId;\r\n\r\n        //Load previously saved data\r\n        if (this._persistantStore){\r\n            let lastListing = (await this._persistantStore.getLastListing(this._file.name));\r\n            persistantList = lastListing.array;\r\n            //If the last scan was not completed then we will just update it..\r\n            if(!lastListing.complete){\r\n                persistantId = lastListing.key;\r\n            }\r\n        }\r\n\r\n        // Create a list of all the baseIds we need to inspect\r\n        let iterateList = Object.keys(self._indexTable).map(i => Number(i));\r\n        for (let index in persistantList) {\r\n            if (!(index in self._indexTable))\r\n                iterateList.push(index);\r\n        }\r\n\r\n        // Helps us to know when we need to update the persistant store\r\n        let updatePersistant = false;\r\n\r\n        //Spawn the decompression tasks\r\n        let taskArray = [];\r\n        for (let i = 0; i<1; i++){\r\n            taskArray[i] = Promise.resolve({task: i});\r\n        }\r\n\r\n        let persistantNeedsUpdate = false;\r\n\r\n        //Iterate through the array\r\n        for(let index in iterateList){\r\n            let baseId = iterateList[index];\r\n\r\n            //First use a synchronous function to know if we need to scan the file\r\n            let result = this._needsScan(baseId, persistantList);\r\n            if(result.scan == true){\r\n                let taskId = (await Promise.race(taskArray)).task;\r\n                taskArray[taskId] = this._readFileType(baseId).then((scanResult) => {\r\n                    //Put the result into our persistant storage\r\n                    persistantList[baseId] = {baseId: baseId, size: scanResult.size, crc: scanResult.crc, fileType: scanResult.fileType};\r\n                    return {task: taskId};\r\n                });\r\n            } \r\n            if (result.change == 'removed'){\r\n                //Update the persistant storage\r\n                delete persistantList[baseId];\r\n            }\r\n\r\n            //Handle persistant storage update\r\n            if(result.change !== 'none')\r\n                persistantNeedsUpdate = true;\r\n\r\n            //Tasks to do only every %\r\n            if(index%Math.floor(iterateList.length/100) == 0){\r\n                //Print progress\r\n                T3D.Logger.log(T3D.Logger.TYPE_PROGRESS,\r\n                    \"Finding types\", index/Math.floor(iterateList.length/100));\r\n\r\n                //Update the persistant storage if needed\r\n                if(self._persistantStore && persistantNeedsUpdate){\r\n                    persistantNeedsUpdate = false;\r\n                    self._persistantStore.putListing(persistantId, persistantList, self._file.name, false).then(res => persistantId = res);\r\n                }\r\n            }\r\n        }\r\n\r\n        await Promise.all(taskArray).then(()=>{\r\n            //Finally update the listing as complete\r\n            if(self._persistantStore)\r\n                self._persistantStore.putListing(persistantId, persistantList, self._file.name, true);\r\n        });\r\n        this._persistantData = persistantList;\r\n        return this.getFileList();\r\n    }\r\n\r\n    /**\r\n     * @typedef {Object} MapItem\r\n     * @property {string} name\r\n     * @property {string} category\r\n     * @property {number} baseId\r\n     */\r\n\r\n    /**\r\n     *   Returns a list of all the maps with their name and category.\r\n     *   Uncategorized maps are available only if readFileList have been used before.\r\n     * \r\n     * @returns {Array<MapItem>}\r\n     */\r\n    getMapList() {\r\n        let self = this;\r\n        let mapArray = [];\r\n        //If the archive have been scanned for all its file we iterate through the results\r\n        if(this._persistantData){\r\n            //Filter the maps out of all our files\r\n            let reversedIndex = this.getReverseIndex();\r\n            let maps = this._persistantData.filter( file => file.fileType === 'PF_mapc')\r\n                .filter(id => id.baseId == reversedIndex[self.getFileIndex(id.baseId)][0]);\r\n            \r\n\r\n            for(let map of maps){\r\n                let found = false;\r\n                //Try to see if we already have some informations on this map\r\n                for(let category of MapFileList.maps){\r\n                    let fileMap = category.maps.find(\r\n                        item => Number(item.fileName.split('.data')[0]) == map.baseId);\r\n                    if(fileMap){\r\n                        mapArray.push({name: fileMap.name, category: category.name, baseId: map.baseId});\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                //If not we register it as Uncategorized\r\n                if(!found)\r\n                    mapArray.push({name: map.baseId.toString(), category: 'Uncategorized', baseId: map.baseId});\r\n            }\r\n        } \r\n        //If not then we check only known maps\r\n        else {\r\n            for(let category of MapFileList.maps){\r\n                for(let mapEntry of category.maps){\r\n                    if(Number(mapEntry.fileName.split('.data')[0]) in this._indexTable)\r\n                        mapArray.push({name: mapEntry.name, category: category.name, baseId: Number(mapEntry.fileName.split('.data')[0])});\r\n                }\r\n            }\r\n        }\r\n        return mapArray;\r\n    }\r\n\r\n\r\n    /**\r\n     * @typedef {Object} FileItem\r\n     * @property {number} mftId\r\n     * @property {Array<number>} baseIdList\r\n     * @property {number} size\r\n     * @property {number} crc\r\n     * @property {string} fileType\r\n     **/\r\n\r\n    /**\r\n     *   Return the meta table with extra information such as an array of baseIds and the file types.\r\n     *   The filetype is available only if readFileList have been used before of course.\r\n     * \r\n     * @returns {Array<FileItem>}\r\n     */\r\n    getFileList() {\r\n        let typeList = (this._persistantData) ? this._persistantData.map( i => i.fileType) : [];\r\n        let reverseBaseIdList = this.getReverseIndex();\r\n\r\n        let fileList = this._fileMetaTable.map((meta, mftId) => {\r\n            let baseIds = (reverseBaseIdList[mftId]) ? reverseBaseIdList[mftId] : [];\r\n            let type = (reverseBaseIdList[mftId]) ? typeList[baseIds[0]] : 'Non-Registered';\r\n            return {\r\n                mftId: mftId,\r\n                baseIdList: baseIds,\r\n                size: meta.size,\r\n                crc: meta.crc,\r\n                fileType: type\r\n            }\r\n        });\r\n        fileList[0] = {mftId: 0, baseIdList: [], size: 0, crc: 0, fileType: 'Non-Registered' };\r\n        return fileList;\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getReverseIndex(){\r\n        return this._indexTable.reduce((reversed, mftId, baseId) => {\r\n            if(mftId in reversed)\r\n                reversed[mftId].push(baseId);\r\n            else\r\n                reversed[mftId] = [baseId];\r\n            return reversed;\r\n        }, []);\r\n    }\r\n\r\n    //API Compatibility\r\n\r\n    \r\n    /**\r\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\r\n     * only the list defined in {@link MapFileList}\r\n     *\r\n     * @deprecated Use now the getFileList method.\r\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\r\n     * If false only reads indices specified in \"T3D/MapFileList\".\r\n     * @param  {Function} callback Fired when the list is generated\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type. For exmample:\r\n     * \r\n     * \t\t{\t\r\n     * \t\t\tmaps:[\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Heart of Maguuma',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t},\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Unknown maps',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t}\r\n     * \t\t\t]\r\n     \r\n    *\t    };\r\n    */\r\n    readMapListAsync(searchAll, callback){\r\n        let self = this;\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.readMapListAsync is deprecated !\");\r\n        \r\n        //Let's preserve the old output way\r\n        function restoreOuput(array){\r\n            let returnArray = [];\r\n            for(let elt of array){\r\n                let category = returnArray.findIndex(i => i.name == elt.category)\r\n                if(category == -1)\r\n                    category = returnArray.push({name: elt.category, maps:[]}) - 1;\r\n                returnArray[category].maps.push({fileName: elt.baseId, name: elt.name});\r\n            }\r\n            //And resort it in order\r\n            returnArray.sort((i,j) => {\r\n                if(i.name < j.name) return -1;\r\n                if(i.name > j.name) return 1;\r\n                return 0;\r\n            })\r\n            return {maps: returnArray};\r\n        }\r\n\r\n        /// If seachAll flag is true, force a deep search\r\n        if(searchAll){\r\n            this.readFileList().then(() => {\r\n                callback(restoreOuput(self.getMapList()));\r\n            })\r\n        } else {\r\n            callback(restoreOuput(self.getMapList()));\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Reads the file type of each file in the dat and stores the resulting list in \r\n     * the browser's local storage.\r\n     * \r\n     * @deprecated Use now the readFileList or getFileList methods.\r\n     * @param  {Function} callback Fired when the list is generated and stores\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type.\r\n     */\r\n    readFileListAsync(callback){\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.readFileListAsync is deprecated !\");\r\n\r\n        //Because the API changed we reform the data as wanted previously\r\n        this.readFileList().then((result) => {\r\n            let returnObj = {};\r\n            for(let fileEntry of result){\r\n                if(returnObj[fileEntry.fileType] === undefined)\r\n                    returnObj[fileEntry.fileType] = [];\r\n                returnObj[fileEntry.fileType].push(fileEntry.mftId);\r\n            }\r\n            callback(returnObj);\r\n        });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Reads data from a file in the dat.\r\n     * \r\n     * @deprecated Use now the Promise-based method readFile.\r\n     * @param  {Number}   baseId   Base or File id of the texture to load\r\n     * @param  {Function} callback Fires when the inflater has read the data.\r\n     *\r\n     * The passed arguments are \r\n     * -ArrayBuffer raw data\r\n     * -Number DXT Type if applicable\r\n     * -Number image width if applicable\r\n     * -Number image height if applicable\r\n     *\r\n     * \r\n     * @param  {boolean}  isImage  \r\n     * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\r\n     */\r\n    loadFile(baseId, callback, isImage, raw){\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadFile is deprecated !\");\r\n        let mftId = this.getFileIndex(baseId);\r\n        if(mftId<=0)\r\n            return callback(null);\r\n        this.readFile(mftId, isImage, raw).then((result) => {\r\n            if(result.buffer == undefined)\r\n                return callback(null);\r\n            callback(result.buffer, result.dxtType, result.imageWidth, result.imageHeight);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reads a bitmap from a texture file in the dat.\r\n     * \r\n     * @deprecated\r\n     * @param  {Number}   baseId   Base or File id of the texture to load\r\n     * @param  {Function} callback Fires when the inflater has read the texture data.\r\n     * \r\n     * The passed arguments are \r\n     * -ArrayBuffer Bitmap\r\n     * -Number DXT Type\r\n     * -Number image width\r\n     * -Number image height\r\n     *\r\n     */\r\n    loadTextureFile(baseId, callback){\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadTextureFile is deprecated !\");\r\n        \r\n        this.loadFile(baseId, callback, true);\r\n    }\r\n\r\n    /**\r\n     * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\r\n     * Now kept only for backward compatibility, but doesn't do anything.\r\n     * Please use getFileList now.\r\n     * \r\n     * @deprecated\r\n     */\r\n    loadFileList(){\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadFileList is deprecated !\");\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\r\n     * Now kept only for backward compatibility, but doesn't do anything.\r\n     * Please use getMapList now.\r\n     *\r\n     * @deprecated\r\n     */\r\n    loadMapList(){\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadMapList is deprecated !\");\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // Private \r\n\r\n\r\n    /**\r\n     * @private\r\n     * @param {number} baseId \r\n     * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData \r\n     * @returns {{scan: boolean, change: string }}\r\n     */\r\n    _needsScan(baseId, persistantData){\r\n        if(baseId <= 0)\r\n            return {change: 'none', scan: false};\r\n\r\n        let mftId = this.getFileIndex(baseId);\r\n        let metaData = this.getFileMeta(mftId);\r\n\r\n        //Nothing interesting\r\n        if(metaData === undefined && !(baseId in persistantData)){\r\n            return {change: 'none', scan: false};\r\n        }\r\n        //If the file have been deleted\r\n        else if(metaData === undefined){\r\n            return {change: 'removed', scan: false};\r\n        }\r\n        //If the file is new\r\n        else if(!(baseId in persistantData)) {\r\n            return {change: 'added', scan: true};\r\n        }\r\n        //If the size or crc don't match\r\n        else if(metaData.size !== persistantData[baseId].size || metaData.crc !== persistantData[baseId].crc){\r\n            return {change: 'modified', scan: true};\r\n        }\r\n        //If everything is the same\r\n        else\r\n        {\r\n            return {change: 'none', scan: false};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {number} baseId \r\n     * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData \r\n     * @returns {Promise<{fileType: string, crc: number, size: number}>}\r\n     */\r\n    async _readFileType(baseId) {\r\n        if(!this._fileTypeCache)\r\n            this._fileTypeCache = [];\r\n\r\n        let mftId = this.getFileIndex(baseId);\r\n        let metaData = this.getFileMeta(mftId);\r\n\r\n        let fileType;\r\n        if(this._fileTypeCache[baseId] != undefined){\r\n            fileType = this._fileTypeCache[baseId];\r\n        } else {\r\n            let fileBuffer = (await this.readFile(mftId, false, false, Math.min(metaData.size, 1000), 32)).buffer;\r\n            if(fileBuffer == undefined)\r\n                return undefined;\r\n            fileType = FileTypes.getFileType(new DataStream(fileBuffer));\r\n        }\r\n        return {fileType: fileType, crc: metaData.crc, size: metaData.size};\r\n    }\r\n}\r\n\r\nmodule.exports = LocalReader;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// T3DLib version\nconst version = require('../T3DLib').version;\n\n/// Indexed DB versioning\nconst DB_VERSION = 4;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n */\nclass PersistantStore{\n\n    constructor() {\n        //They may be multiple connection request issued at the same time, but it's actually okay since\n        //as soon as they are registered, the not-used ones will get garbage collected\n        this._dbConnection = undefined;\n        this._getConnection(()=>{});\n    }\n\n    /**\n     *   Initialize the IndexedDB connection and manages version changes.\n     * \n     * @async\n     * @private\n     * @returns {Promise<IDBDatabase>} Promise to the Database connection\n     */\n    _getConnection(){\n        let self = this;\n        return new Promise((resolve, reject) => {\n            if(self._dbConnection)\n                resolve(self._dbConnection);\n\n            // Let us open our database\n            let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n            \n            /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n            request.onblocked = (event) =>  {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_ERROR,\n                    \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n                );\n            }\n\n            /// fired when the database needs to be upgraded (or the first time)\n            request.onupgradeneeded = (event) => {\n                /** @type {IDBDatabase} */\n                let db = event.target.result;\n                let currentVersion = event.oldVersion;\n\n                if(currentVersion < 2){\n                    let newstore = db.createObjectStore(\"listings\", {autoIncrement: true});\n                }\n\n                if(currentVersion < 3){\n                    let storeListing = event.currentTarget.transaction.objectStore(\"listings\");\n                    storeListing.createIndex('filename', 'filename', {unique: false});\n                }\n\n            }\n\n            request.onsuccess = (event) => {\n                self._dbConnection = event.target.result;\n                self.isReady = true;\n                resolve(self._dbConnection);\n            }\n\n            request.onerror = (event) => {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_ERROR,\n                    \"The T3D persistant database could not be opened.\"\n                );\n                reject();\n            }\n        });\n    }\n\n    /**\n     *   Add or update a listing into the database\n     * \n     * @async\n     * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\n     * @param {Array} listing \n     * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n     * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\n     * @returns {Promise<number>} On success, the number is the object key in the database\n     */\n    putListing(id, listing, fileName, isComplete){\n        let self = this;\n        return new Promise((resolve, reject) => {\n            self._getConnection().then((db) => {\n                let store = db.transaction([\"listings\"], \"readwrite\").objectStore(\"listings\");\n\n                let request = (id) ? store.put({array: listing, filename: fileName, complete: isComplete}, id) : store.put({array: listing, name: fileName});\n    \n                request.onsuccess = (event) => {\n                    resolve(request.result);\n                }\n                request.onerror = (event) => {\n                    reject();\n                }\n            })\n        });\n    }\n\n    /**\n     * Returns the last valid listing in the database\n     * \n     * @async\n     * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n     * @returns {Promise<{array: Array, key: number, complete: boolean}>}\n     *      array: the last listing\n     *      key: the index of the last listing in the database\n     */\n    getLastListing(fileName) {\n        let self = this;\n        return new Promise((resolve, reject) => {\n            self._getConnection().then((db) => {\n                let listingsStore = db.transaction([\"listings\"], \"readonly\")\n                    .objectStore(\"listings\").index(\"filename\");\n                \n                listingsStore.openCursor(IDBKeyRange.only(fileName), \"prev\").onsuccess = (event) => {\n                    let cursor = event.target.result;\n                    if(!cursor)\n                        resolve({array: [], key: undefined, complete: true});\n                    else {\n                        resolve({array: cursor.value.array, key: cursor.primaryKey, complete: cursor.value.complete});\n                    }\n                        \n                }\n            });\n        });\n    }\n}\n\nmodule.exports = PersistantStore;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n * \n * @namespace\n * @static \n */\nvar Logger = {};\n\n/**\n * @readonly\n * @property {number} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @readonly\n * @property {number} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @readonly\n * @property {number} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @readonly\n * @property {number} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @readonly\n * @property {number} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *  \n * The following arguments are passed to a logging function matching the\n * severity.\n * \n \n * \n */\nLogger.log = function(){\n\n\t/// Require at least 1 argument\n\tif(arguments.length == 0){\n\t\treturn;\n\t}\n\t\n\t/// Parse arguments to an actual array\n\tvar argArr = Logger.argsToArr(arguments);\n\n\t/// Default to message if just one argument was passed\n\tif(argArr.length == 1){\n\t\targArr.unshift(Logger.TYPE_MESSAGE);\n\t}\n\n\t/// Otherwise 1st arg is severity, log/warn/error\n\tvar severity = Math.max(0,Math.min(Logger.logFunctions.length, argArr.shift()));\n\tvar logFunc  = Logger.logFunctions[severity];\n\n\t/// Ouput the rest of the arguments\n\tlogFunc.apply(this, argArr);\n}\n\nLogger.argsToArr = function(args){\n\tvar argArr = new Array(args.length);\n    for(var i = 0; i < argArr.length; ++i) {\n        argArr[i] = args[i];\n    }\n    return argArr;\n}\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function(){\n\tconsole.error.apply(console,arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function(){\n\tconsole.warn.apply(console,arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function(){\n\tconsole.log.apply(console,arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function(){\n\tvar argArr = Logger.argsToArr(arguments);\n\targArr.unshift(\"Progress: \");\n\tconsole.log.apply(console,argArr);\n}\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function(){\n\tvar argArr = Logger.argsToArr(arguments);\n\tconsole.debug.apply(console,argArr);\n}\n\n\nmodule.exports = Logger;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n    /**\n     * @property maps\n     * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\n     */\n    maps: [\n        {\n            name: \"01. Shiverpeaks\",\n            maps: [\n                { fileName: \"125199.data\", name: \"Wayfarer Foothills (0)\" },\n                { fileName: \"187611.data\", name: \"Wayfarer Foothills (1)\" },\n                { fileName: \"568778.data\", name: \"Cragstead\" },\n                { fileName: \"132434.data\", name: \"Hoelbrak (0)\" },\n                { fileName: \"197122.data\", name: \"Hoelbrak (1)\" },\n                { fileName: \"1966018.data\", name: \"Hoelbrak (2)\" },\n                { fileName: \"124093.data\", name: \"Snowden Drifts (0)\" },\n                { fileName: \"186397.data\", name: \"Snowden Drifts (1)\" },\n                { fileName: \"275155.data\", name: \"Dredgehaunt Cliffs\" },\n                { fileName: \"276252.data\", name: \"Frostgorge Sound\" },\n                { fileName: \"277587.data\", name: \"Lornar's Pass\" },\n                { fileName: \"278717.data\", name: \"Timberline Falls (0)\" },\n                { fileName: \"846866.data\", name: \"Timberline Falls (1)\" },\n                { fileName: \"1018612.data\", name: \"Timberline Falls (2)\" },\n                { fileName: \"295282.data\", name: \"Eye of the North\" },\n            ]\n        },\n        {\n            name: \"02. Ascalon\",\n            maps: [\n                { fileName: \"126118.data\", name: \"Plains of Ashford (0)\" },\n                { fileName: \"188591.data\", name: \"Plains of Ashford (1)\" },\n                { fileName: \"127888.data\", name: \"Diessa Plateau (0)\" },\n                { fileName: \"190490.data\", name: \"Diessa Plateau (1)\" },\n                { fileName: \"131944.data\", name: \"Black Citadel (0)\" },\n                { fileName: \"196585.data\", name: \"Black Citadel (1)\" },\n                { fileName: \"1968107.data\", name: \"Black Citadel (2)\" },\n                { fileName: \"280025.data\", name: \"Blazeridge Steppes\" },\n                { fileName: \"281313.data\", name: \"Fireheart Rise\" },\n                { fileName: \"282668.data\", name: \"Iron Marches\" },\n                { fileName: \"283574.data\", name: \"Fields of Ruin\" },\n            ]\n        },\n        {\n            name: \"03. Kryta\",\n            maps: [\n                { fileName: \"191000.data\", name: \"Lion's Arch (0)\" },\n                { fileName: \"814803.data\", name: \"Lion's Arch (1)\" },\n                { fileName: \"1019669.data\", name: \"Lion's Arch (Legacy)\" },\n                { fileName: \"1796999.data\", name: \"Lion's Arch (2)\" },\n                { fileName: \"1869665.data\", name: \"Lion's Arch (3)\" },\n                { fileName: \"1968576.data\", name: \"Lion's Arch (4)\" },\n                { fileName: \"128151.data\", name: \"Divinity's Reach (0)\" },\n                { fileName: \"191265.data\", name: \"Divinity's Reach (1)\" },\n                { fileName: \"705746.data\", name: \"Divinity's Reach (2)\" },\n                { fileName: \"1968748.data\", name: \"Divinity's Reach (3)\" },\n                { fileName: \"129834.data\", name: \"North of Divinity's Reach (0)\" },\n                { fileName: \"193081.data\", name: \"North of Divinity's Reach (1)\" },\n                { fileName: \"129524.data\", name: \"Queensdale (0)\" },\n                { fileName: \"192711.data\", name: \"Queensdale (1)\" },\n                { fileName: \"130970.data\", name: \"Kessex Hills (0)\" },\n                { fileName: \"194288.data\", name: \"Kessex Hills (1)\" },\n                { fileName: \"672138.data\", name: \"Kessex Hills (2)\" },\n                { fileName: \"861815.data\", name: \"Kessex Hills (3)\" },\n                { fileName: \"286945.data\", name: \"Bloodtide Coast\" },\n                { fileName: \"287870.data\", name: \"Harathi Hinterlands\" },\n                { fileName: \"289176.data\", name: \"Gendarran Fields\" },\n                { fileName: \"295005.data\", name: \"Chantry of Secrets\" },\n                { fileName: \"294938.data\", name: \"Claw Island\" },\n            ]\n        },\n        {\n            name: \"04. Maguuma Jungle\",\n            maps: [\n                { fileName: \"195149.data\", name: \"Caledon Forest\" },\n                { fileName: \"195493.data\", name: \"Metrica Province\" },\n                { fileName: \"922320.data\", name: \"Metrica Province Instance\" },\n                { fileName: \"198076.data\", name: \"The Grove (0)\" },\n                { fileName: \"1969341.data\", name: \"The Grove (1)\" },\n                { fileName: \"198272.data\", name: \"Rata Sum (0)\" },\n                { fileName: \"1968896.data\", name: \"Rata Sum (1)\" },\n                { fileName: \"291064.data\", name: \"Mount Maelstrom\" },\n                { fileName: \"292254.data\", name: \"Sparkfly Fen\" },\n                { fileName: \"293307.data\", name: \"Brisban Wildlands\" },\n            ]\n        },\n        {\n            name: \"05. Ruins of Orr\",\n            maps: [\n                { fileName: \"284829.data\", name: \"Straits of Devastation\" },\n                { fileName: \"285089.data\", name: \"Malchor's Leap\" },\n                { fileName: \"285634.data\", name: \"Cursed Shore\" },\n                { fileName: \"295179.data\", name: \"Cathedral of Hidden Depths\" },\n                { fileName: \"295962.data\", name: \"A Light in the Darkness\" },\n            ]\n        },\n        {\n            name: \"06. Living World S1\",\n            maps: [\n                { fileName: \"520479.data\", name: \"Southsun Cove\" },\n                { fileName: \"679089.data\", name: \"Tower of Nightmares\" },\n            ]\n        },\n        {\n            name: \"07. Living World S2\",\n            maps: [\n                { fileName: \"836211.data\", name: \"Dry top (0)\" },\n                { fileName: \"861770.data\", name: \"Dry top (1)\" },\n                { fileName: \"909361.data\", name: \"The Silverwastes (0)\" },\n                { fileName: \"996202.data\", name: \"The Silverwastes (1)\" },\n                { fileName: \"908730.data\", name: \"Glint's Lair\" },\n            ]\n        },\n        {\n            name: \"08. Heart of Maguuma\",\n            maps: [\n                { fileName: \"969663.data\", name: \"Verdant Brink\" },\n                { fileName: \"1262460.data\", name: \"Hearts and Minds\" },\n                { fileName: \"969964.data\", name: \"Unknown Airship in tree\" },\n                { fileName: \"1262310.data\", name: \"Dragon Stand\" },\n                { fileName: \"1263739.data\", name: \"Tarir\" },\n                { fileName: \"1264291.data\", name: \"Tangled Depths\" },\n            ]\n        },\n        {\n            name: \"09. Living World S3\",\n            maps: [\n                { fileName: \"1472635.data\", name: \"(E1) Bloodstone Fen\" },\n                { fileName: \"1498071.data\", name: \"(E2) Taimi Simulator\" },\n                { fileName: \"1498578.data\", name: \"(E2) Ring of Fire\" },\n                { fileName: \"1605211.data\", name: \"(E3) Bitterfrost Frontier\" },\n                { fileName: \"1645474.data\", name: \"(E4) Caudecus Manor\" },\n                { fileName: \"1646520.data\", name: \"(E4) Lake Doric\" },\n                { fileName: \"1682493.data\", name: \"(E5) Draconis Mons\" },\n                { fileName: \"1682763.data\", name: \"(E5) Titan's Throat\" },\n                { fileName: \"1734839.data\", name: \"(E6) White Mantle Fortress\" },\n                { fileName: \"1735346.data\", name: \"(E6) Siren's Landing\" },\n                { fileName: \"1735440.data\", name: \"(E6) Shining Blade Headquarters\" },\n            ]\n        },\n        {\n            name: \"10. Crystal Desert\",\n            maps: [\n                { fileName: \"1794574.data\", name: \"Crystal Oasis\" },\n                { fileName: \"1833034.data\", name: \"Desert Highlands\" },\n                { fileName: \"1833726.data\", name: \"PoF story instances\" },\n                { fileName: \"1839188.data\", name: \"Domain of Vabbi\" },\n                { fileName: \"1840103.data\", name: \"Elon Riverlands\" },\n                { fileName: \"1840368.data\", name: \"Kormir Sanctuary\" },\n                { fileName: \"1842533.data\", name: \"The Desolation\" },\n            ]\n        },\n        {\n            name: \"11. Living World S4\",\n            maps: [\n                { fileName: \"1901428.data\", name: \"(E1) Fahranur\" },\n                { fileName: \"1902235.data\", name: \"(E1) Istan\" },\n                { fileName: \"1903523.data\", name: \"(E1) Crystal Oasis\" },\n                { fileName: \"1954984.data\", name: \"(E2) Desert Highlands\" },\n                { fileName: \"1955224.data\", name: \"(E2) Inquest Lab Tower\" },\n                { fileName: \"1955471.data\", name: \"(E2) Rata Primus\" },\n                { fileName: \"1955642.data\", name: \"(E2) Divinity's Reach\" },\n                { fileName: \"1955915.data\", name: \"(E2) Mount Maelstrom\" },\n                { fileName: \"1956140.data\", name: \"(E2) Frostgorge Sound\" },\n                { fileName: \"1956245.data\", name: \"(E2) Void\" },\n                { fileName: \"1956299.data\", name: \"(E2) Hided Inquest Lab\" },\n                { fileName: \"1957526.data\", name: \"(E2) Sandswept Isles\" },\n                { fileName: \"2005467.data\", name: \"(E3) Crystal Oasis\" },\n                { fileName: \"2004704.data\", name: \"(E3) Domain of Koruna\" },\n            ]\n        },\n        {\n            name: \"12. Seasonal Activities\",\n            maps: [\n                { fileName: \"506592.data\", name: \"Ascent to Madness\" },\n                { fileName: \"506670.data\", name: \"Mad King's Labyrinth (Past)\" },\n                { fileName: \"662436.data\", name: \"Mad King's Labyrinth (Present)\" },\n                { fileName: \"506739.data\", name: \"Mad King's Clock Tower\" },\n                { fileName: \"622681.data\", name: \"The Crown Pavilion\" },\n                { fileName: \"569756.data\", name: \"SAB Hub (0)\" },\n                { fileName: \"636133.data\", name: \"SAB Hub (1)\" },\n                { fileName: \"635555.data\", name: \"SAB World 1\" },\n                { fileName: \"635960.data\", name: \"SAB World 2\" },\n                { fileName: \"606255.data\", name: \"Zephyr Sanctum\" },\n                { fileName: \"529896.data\", name: \"Tixx's Infinirarium\" },\n                { fileName: \"529945.data\", name: \"Winter Wonderland\" },\n            ]\n        },\n        {\n            name: \"13. Activites\",\n            maps: [\n                { fileName: \"605983.data\", name: \"Sanctum Sprint\" },\n                { fileName: \"606030.data\", name: \"Basket Brawl\" },\n            ]\n        },\n        {\n            name: \"14. Dungeons\",\n            maps: [\n                { fileName: \"126840.data\", name: \"Ascalonian Catacombs (0)\" },\n                { fileName: \"189364.data\", name: \"Ascalonian Catacombs (1)\" },\n                { fileName: \"275474.data\", name: \"Sorrow's Embrace\" },\n                { fileName: \"276520.data\", name: \"Honor of the Waves\" },\n                { fileName: \"284039.data\", name: \"Citadel of Flame\" },\n                { fileName: \"287214.data\", name: \"Caudecus's Manor\" },\n                { fileName: \"291284.data\", name: \"Twilight Arbor (0)\" },\n                { fileName: \"645968.data\", name: \"Twilight Arbor (1)\" },\n                { fileName: \"293606.data\", name: \"Crucible of Eternity\" },\n                { fileName: \"473930.data\", name: \"The Ruined City of Arah\" },\n                { fileName: \"473765.data\", name: \"Arah - Story\" },\n                { fileName: \"580061.data\", name: \"Molten Facility\" },\n                { fileName: \"595722.data\", name: \"Aetherblade Retreat\" },\n            ]\n        },\n        {\n            name: \"15. Fractals\",\n            maps: [\n                { fileName: \"519839.data\", name: \"Fractals of the Mists\" },\n                { fileName: \"697450.data\", name: \"Thaumanova Reactor\" },\n                { fileName: \"1426653.data\", name: \"Cliffside Fractal\" },\n                { fileName: \"1472361.data\", name: \"Chaos Isle Fractal\" },\n                { fileName: \"1472382.data\", name: \"Snowblind Fractal\" },\n                { fileName: \"1472406.data\", name: \"Swampland Fractal\" },\n                { fileName: \"1498016.data\", name: \"Mistlock Observatory\" },\n                { fileName: \"1498798.data\", name: \"Aetherblade/Mai Trin Fractal\" },\n                { fileName: \"1605344.data\", name: \"Nightmare Fractal\" },\n                { fileName: \"1733857.data\", name: \"Shattered Observatory Fractal\" },\n                { fileName: \"1733961.data\", name: \"Mistlock Sanctuary\" },\n                { fileName: \"1905739.data\", name: \"Molten Boss Fractal\" },\n                { fileName: \"1905889.data\", name: \"Twilight Oasis Fractal\" },\n                { fileName: \"2005713.data\", name: \"Deepstone Fractal\" },\n            ]\n        },\n        {\n            name: \"16. Raid\",\n            maps: [\n                { fileName: \"1151420.data\", name: \"(W1) Spirit Vale\" },\n                { fileName: \"1383309.data\", name: \"(W2) Salvation Pass\" },\n                { fileName: \"1427048.data\", name: \"Special Forces Training Area\" },\n                { fileName: \"1454070.data\", name: \"(W3) Stronghold of the Faithful\" },\n                { fileName: \"1645215.data\", name: \"(W4) Bastion of the Penitent\" },\n                { fileName: \"1906329.data\", name: \"(W5) Hall of Chains\" },\n            ]\n        },\n        {\n            name: \"17. Structured PvP\",\n            maps: [\n                { fileName: \"871093.data\", name: \"Original Stronghold\" },\n                { fileName: \"870987.data\", name: \"Battle of Champion's Dusk (0)\" },\n                { fileName: \"1666233.data\", name: \"Battle of Champion's Dusk (1)\" },\n                { fileName: \"132570.data\", name: \"Heart of the Mists (0)\" },\n                { fileName: \"197249.data\", name: \"Heart of the Mists (1)\" },\n                { fileName: \"1734729.data\", name: \"Heart of the Mists (2)\" },\n                { fileName: \"1712986.data\", name: \"Hall of the Mists\" },\n                { fileName: \"132710.data\", name: \"The Battle of Khylo (0)\" },\n                { fileName: \"197402.data\", name: \"The Battle of Khylo (1)\" },\n                { fileName: \"132837.data\", name: \"Forest of Niflhel (0)\" },\n                { fileName: \"197545.data\", name: \"Forest of Niflhel (1)\" },\n                { fileName: \"376916.data\", name: \"Legacy of the Foefire\" },\n                { fileName: \"467374.data\", name: \"Raid on the Capricorn\" },\n                { fileName: \"520609.data\", name: \"Temple of the Silent Storm\" },\n                { fileName: \"579383.data\", name: \"Skyhammer (0)\" },\n                { fileName: \"677968.data\", name: \"Skyhammer (1)\" },\n                { fileName: \"1934470.data\", name: \"Skyhammer (2)\" },\n                { fileName: \"791564.data\", name: \"Courtyard (0)\" },\n                { fileName: \"1713054.data\", name: \"Courtyard (1)\" },\n                { fileName: \"556199.data\", name: \"Spirit Watch (0)\" },\n                { fileName: \"1473061.data\", name: \"Spirit Watch (1)\" },\n                { fileName: \"506539.data\", name: \"Reaper's Rumble\" },\n                { fileName: \"529718.data\", name: \"Snowball Mayhem\" },\n                { fileName: \"595582.data\", name: \"Dragon Ball Arena\" },\n                { fileName: \"617120.data\", name: \"Aspect Arena\" },\n                { fileName: \"1644624.data\", name: \"Revenge of the Capricorn\" },\n                { fileName: \"1704155.data\", name: \"Eternal Coliseum\" },\n            ]\n        },\n        {\n            name: \"18. World vs World\",\n            maps: [\n                { fileName: \"131235.data\", name: \"Eternal Battlegrounds (0)\" },\n                { fileName: \"195806.data\", name: \"Eternal Battlegrounds (1)\" },\n                { fileName: \"1885693.data\", name: \"Eternal Battlegrounds (2)\" },\n                { fileName: \"1918037.data\", name: \"Eternal Battlegrounds (3)\" },\n                { fileName: \"131574.data\", name: \"Alpine Borderlands (0)\" },\n                { fileName: \"641501.data\", name: \"Alpine Borderlands (1)\" },\n                { fileName: \"1799855.data\", name: \"Alpine Borderlands (2)\" },\n                { fileName: \"1647236.data\", name: \"Desert Borderlands (0)\" },\n                { fileName: \"1799442.data\", name: \"Desert Borderlands (1)\" },\n                { fileName: \"736241.data\", name: \"Edge of the Mists\" },\n            ]\n        },\n        {\n            name: \"19. Guild Halls\",\n            maps: [\n                { fileName: \"1255378.data\", name: \"Gilded Hollow\" },\n                { fileName: \"1256064.data\", name: \"Lost Precipice\" },\n                { fileName: \"1843274.data\", name: \"Windswept Haven\" },\n            ]\n        },\n        {\n            name: \"20. Concept and not released\",\n            maps: [\n                { fileName: \"122695.data\", name: \"Empty Plane\" },\n                { fileName: \"184799.data\", name: \"Empty Plane v1\" },\n                { fileName: \"197562.data\", name: \"Empty Plane v2\" },\n                { fileName: \"875614.data\", name: \"Unknown Mists Platforms\" },\n                { fileName: \"132853.data\", name: \"Empty Box\" },\n                { fileName: \"1255516.data\", name: \"Guild Coliseum\" },\n                { fileName: \"1498193.data\", name: \"Concept sPVP Map 1\" },\n                { fileName: \"1513556.data\", name: \"Concept sPVP Map 2\" },\n                { fileName: \"1513607.data\", name: \"Concept sPVP Map 3\" },\n                { fileName: \"1513620.data\", name: \"Concept sPVP Map 4\" },\n                { fileName: \"1513675.data\", name: \"Concept sPVP Map 5\" },\n                { fileName: \"1712945.data\", name: \"Concept sPVP Map 6\" },\n            ]\n        },\n\n    ]\n}","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* INCLUDES */\nvar LocalReader = require('./LocalReader/LocalReader');\n\n/* PRIVATE VARS */\nvar _version = \"1.1.2\";\nvar _settings = {\n\tt3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n\tconcurrentTasks: (typeof navigator != 'undefined') ? navigator.hardwareConcurrency : 1,\n};\n\n\nlet T3D;\n\n/* PUBLIC PROPERTIES */\n\n\n/**\n * Tyria 3D Library main module.\n * \n * Use this static class to access file parsers- and data renderer classes.\n * \n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n * @module T3D\n */\nT3D = module.exports = {\n\n\t/**\n\t * The current library version. Used to make sure local storage caches are not\n\t * shared between different releases.\n\t *\n\t * @property version\n\t * @type String\n\t */\n\tversion : _version,\n\n\n\t/* FILES */\n\n\t/**\n\t * A static reference to the GW2File class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @memberof T3D\n\t * @property GW2File\n\t * @type Class\n\t */\n\tGW2File  : require(\"./format/file/GW2File\"),\n\n\t/**\n\t * A static reference to the GW2Chunk class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @memberOf T3D\n\t * @property GW2Chunk\n\t * @type Class\n\t */\n\tGW2Chunk  : require(\"./format/file/GW2Chunk\"),\n\n\n\t/* RENDERERS */\n\n\t/**\n\t * A static reference to the DataRenderer class, the preferred way of\n\t * accessing this class.\n\t * \n\t * @readonly\n\t * @property DataRenderer\n\t * @type Class\n\t */\n\tDataRenderer  : require(\"./dataRenderer/DataRenderer\"),\n\n\t/**\n\t * A static reference to the EnvironmentRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property EnvironmentRenderer\n\t * @type Class\n\t */\n\tEnvironmentRenderer  : require(\"./dataRenderer/EnvironmentRenderer\"),\n\n\t/**\n\t * A static reference to the HavokRenderer class, the preferred way of\n\t * accessing this class.\n\t * \n\t * @readonly\n\t * @property HavokRenderer\n\t * @type Class\n\t */\n\tHavokRenderer  : require(\"./dataRenderer/HavokRenderer\"),\n\n\t/**\n\t * A static reference to the PropertiesRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property PropertiesRenderer\n\t * @type Class\n\t */\n\tPropertiesRenderer  : require(\"./dataRenderer/PropertiesRenderer\"),\n\n\t/**\n\t * A static reference to the SingleModelRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property SingleModelRenderer\n\t * @type Class\n\t */\n\tSingleModelRenderer  : require(\"./dataRenderer/SingleModelRenderer\"),\n\n\t/**\n\t * A static reference to the TerrainRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property TerrainRenderer\n\t * @type Class\n\t */\n\tTerrainRenderer  : require(\"./dataRenderer/TerrainRenderer\"),\n\n\t/**\n\t * A static reference to the ZoneRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property ZoneRenderer\n\t * @type Class\n\t */\n\tZoneRenderer  : require(\"./dataRenderer/ZoneRenderer\"),\n\n\t/**\n\t * A static reference to the StringRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property StringRenderer\n\t * @type Class\n\t */\n\tStringRenderer  : require(\"./dataRenderer/StringRenderer\"),\n\n\n\n\n\t/* LOGGING */\n\n\t/**\n\t * A static reference to the static Logger object, the preferred way of\n\t * accessing this object. A simple way of providing your own logging methods\n\t * is to simply overwrite any or all of the logging methods specified in \n\t * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n\t *\n\t * @property Logger\n\t * @type Object\n\t */\n\tLogger  : require(\"./Logger\"),\n\n\n\t/* SETTINGS */\n\n\t/**\n\t * Contains a list of known map fileID:s and their names. Used in order to quickly\n\t * look up what maps are in a .dat file. Note that this property is hard coded and\n\t * has high probablity of being outdated. Also note that the names are just guesses\n\t * by RequestTimeout.\n\t *\n\t * The format of this list objects is\n\t *\n\t * \n\t * \t{ \n\t *  \tmaps : [\n\t *\t  \t\t{\n\t *     \t\t\tname:\"World Area Name\",\n\t *\t       \t\tmaps:[\n\t *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n\t*\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\t\t\n\t*\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n\t*\t              ]\n\t*           },\n\t*\t         {\n\t*\t\t\t    name:\"Another World Area Name\",\n\t*\t\t \t   \tmaps:[\n\t*\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n\t*\t\t\t    ]\n\t*\t\t     }\n\t* \t\t]\n\t*   }\n\t*\n\t* @readonly\n\t* @property MapFileList\n\t* @type Object\n\t*/\n\tMapFileList  : require(\"./MapFileList\"),\n\n\t/* UTILS */\n\n\t/**\n\t * A static reference to the MaterialUtils class.\n\t *\n\t * @readonly\n\t * @property MaterialUtils\n\t * @type Object\n\t */\n\tMaterialUtils  : require('./util/MaterialUtils.js'),\n\n\t/**\n\t * A static reference to the MathUtils class.\n\t *\n\t * @readonly\n\t * @property MathUtils\n\t * @type Object\n\t */\n\tMathUtils  : require('./util/MathUtils.js'),\n\n\t/**\n\t * A static reference to the ParserUtils class.\n\t *\n\t * @readonly\n\t * @property ParserUtils\n\t * @type Object\n\t */\n\tParserUtils  : require('./util/ParserUtils.js'),\n\n\n\t/**\n\t * A static reference to the RenderUtils class.\n\t *\n\t * @readonly\n\t * @property RenderUtils\n\t * @type Object\n\t */\n\tRenderUtils  : require('./util/RenderUtils.js'),\n\n\t/**\n\t * A static reference to the PersistantStore class.\n\t * \n\t * @readonly\n\t * @property PersistantStore\n\t * @type Class\n\t */\n\tPersistantStore  : require('./LocalReader/PersistantStore'),\n\n\t/**\n\t * A static reference to the FileTypes tools and list.\n\t * \n\t * @readonly\n\t * @property FileTypes\n\t * @type Object\n\t */\n\tFileTypes  : require('./LocalReader/FileTypes'),\n\n\t/* PUBLIC METHODS */\n\n\n\t/**\n\t * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\n\t * \n\t * @async\n\t * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n\t * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n\t *                             \t\tconstructed. Takes no arguments.\n\t *                             \t\t\n\t * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n\t *                               \t_settings.t3dtoolsWorker will be used instead.\n\t * \n\t * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n\t *                             \t\twill not be fully initialized until the callback\n\t *                             \t\tis fired.\n\t */\n\tgetLocalReader : function(file, callback, t3dtoolsWorker){\n\n\t\tlet path = (t3dtoolsWorker) ? t3dtoolsWorker : _settings.t3dtoolsWorker;\n\t\t\n\t\t//Create the instance and init the threads\n\t\tvar lrInstance = new LocalReader({workerPath: path, workersNb: _settings.concurrentTasks });\n\n\t\t/// Callback with the lrInstance\n\t\tlrInstance.openArchive(file).then(() => {\n\t\t\tcallback(lrInstance);\n\t\t});\n\n\t\treturn lrInstance;\n\t},\n\n\t/**\n\t * Utility method for acceccing a list containing information about all files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * Note that peeking the files is the time consuming task, so if you don't want\n\t * yout application to spend time indexing the .dat and have a priori knowledge\n\t * about the required file Id's you should not use this method.\n\t * \n\t * @async\n\t * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n\t * @param  {Function}\t\tcallback    Fires when the index has been loaded\n\t *                                 \t\tfrom the localstorage or after it has\n\t *                                 \t\tbeen built and stored in localstorage.\n\t *                                 \t\tTakes the generated object list of\n\t *                                 \t\tfiles as an argument. This list groups\n\t *                                 \t\tarrays of MFT indices per file type,\n\t *                                 \t\tfor exmample:\n\t *\n\t * \n\t * \t{\n\t *\t  \t\"Unknown\"\t: [444, 555, 333],\n\t*\t  \t\"MODL\"\t\t: [444, 555, 333],\n\t* \t  \t\"String\"\t: [666, 777, 888]\n\t* \t}\n\t* \n\t* For more details see\n\t* {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n\t*/\n\tgetFileListAsync : function(localReader, callback){\n\n\t\t/// Check local storage for an existing file list\n\t\tvar fileList = localReader.loadFileList();\n\n\t\t/// If there is no cached list, look for pre-defined maps.\n\t\tif(!fileList){\n\t\t\tlocalReader.readFileListAsync(callback);\n\t\t}\n\n\t\t/// Otherwise, just fire the callback with the cached list\n\t\telse{\n\t\t\tcallback(fileList);\n\t\t}\n\t\t\n\t},\n\n\t/**\n\t * Utility method for acceccing a list containing information about all map files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * If the searchAll flag is not set to true, this process will only scan files\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n\t * \n\t * @async\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n\t * @param {Function}\tcallback\tFires when the index has been loaded\n\t *                                 \tfrom the localstorage or after it has\n\t *                                 \tbeen built and stored in localstorage.\n\t *                                 \tTakes the generated object list of\n\t *                                 \tfiles as an argument. This list groups\n\t *                                 \tarrays of MFT indices per file type,\n\t *                                 \tfor exmample:\n\t * \n\t * \t\t{\t\n\t * \t\t\tmaps:[\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t},\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Unknown maps',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t}\n\t * \t\t\t]\n\t \n\t*\t    };\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\n\t*/\n\tgetMapListAsync : function(localReader, callback, searchAll){\n\n\t\t/// If seachAll flag is true, force a deep search\n\t\tif(searchAll){\n\t\t\tlocalReader.readMapListAsync(true, callback);\n\t\t\treturn;\n\t\t}\n\n\t\t/// Check local storage for an existing map list\n\t\tvar mapList = localReader.loadMapList();\n\n\t\t/// If there is no cached list, look for pre-defined maps.\n\t\tif(!mapList){\n\t\t\tlocalReader.readMapListAsync(false, callback);\n\t\t}\n\n\t\t/// Otherwise, just fire the callback with the cached list\n\t\telse{\n\t\t\tcallback(mapList);\n\t}\n\t\t\n\t},\n\n\t/**\n\t * Utility method used for rendering map files. Loads a map file and applies\n\t * the provided renderers to it.\n\t * \n\t * @async\n\t * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n\t * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n\t * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n\t *                               \t\tclass should extend \n\t *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n\t * @param  {Function}\t\tcallback    Callback function, takes the shared\n\t *                                 \t\trenderer context as an argument.\n\t * @param  {Class}\t\t\tlogger      A logger class of the same type as\n\t *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n\t */\n\trenderMapContentsAsync : function(localReader, fileName, renderers, callback, logger){\n\n\t\t/// VO for storing result from renderers\n\t\tvar context = {};\n\n\t\t/// Make sure we got an actuall ID number\t\t\n\t\tif(parseInt(fileName)){\n\n\t\t\t/// File name is baseId, load using local reader.\n\t\t\tlocalReader.loadFile(\n\t\t\t\tfileName,\n\t\t\t\tfunction(arrayBuffer){\n\n\t\t\t\t\t/// Set up datastream\n\t\t\t\t\tvar ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n\t\t\t\t\t/// Initiate Map file object. Connect callback\n\t\t\t\t\tvar mapFile = new T3D.GW2File(ds, 0);\n\n\t\t\t\t\t/// Populate VO by running the renderers\n\t\t\t\t\tvar runAllRenderers = function(i){\n\t\t\t\t\t\t\n\t\t\t\t\t\t/// Run each renderer\n\t\t\t\t\t\tif(i < renderers.length ){\n\t\t\t\t\t\t\tT3D.runRenderer(\n\t\t\t\t\t\t\t\trenderers[i].renderClass,\n\t\t\t\t\t\t\t\tlocalReader,\n\t\t\t\t\t\t\t\tObject.assign(renderers[i].settings,{mapFile:mapFile}),\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\trunAllRenderers.bind(this,i+1)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/// Fire callback with VO when done\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tcallback(context);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/// Starting point for running each renderer\n\t\t\t\t\trunAllRenderers(0);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t/// Primitive error message...\n\t\telse{\n\t\t\tvar outputLogger = logger ? logger : T3D.Logger;\n\t\t\toutputLogger.log(\n\t\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\t\"Map id must be an integer!, was:\",fileName\n\t\t\t);\n\t\t}\t\n\t},\n\n\t/**\n\t * Utility method for applying a single renderer to a LocalReader insatnce.\n\t * \n\t * @async\n\t * \n\t * @param  {Class}\t\trenderClass\tA class extending \n\t *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n\t * @param  {LocalReader}localReader A fully initialized LocalReader instance\n\t * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n\t *                               \tspecifies thinks like what file ID should\n\t *                               \tbe loaded.\n\t * @param  {Object}\t\tcontext     The shared renderer context value object.\n\t * @param  {Function} \tcb          Callback method passed to the renderAsync\n\t *                                 \tmethod of the renderer.\n\t */\n\trunRenderer : function(renderClass, localReader , settings, context, cb){\n\t\tvar r = new renderClass(\n\t\t\tlocalReader,\n\t\t\tsettings,\n\t\t\tcontext\n\t\t);\n\n\t\tr.renderAsync(cb);\n\t},\n\n\n\t/**\n\t * @param  {Object} context      \tA shared renderer context value object.\n\t * @param  {Class} \tclazz        \tA class extending\n\t *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n\t *                                \tSpecifies for renderer class you want to read \n\t *                                \toutput.\n\t * @param  {String} propName     \tThe name of the property written by the\n\t *                                \trenderer that should retrtieved.\n\t * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n\t *                              \tbe found.\n\t * @return {any}    \t\t\t\tThe specified value from the conext if any,\n\t *                          \t\totherwise defaultValue.\n\t */\n\tgetContextValue : function(context, clazz , propName, defaultValue){\n\t\tvar output = context[clazz.name];\n\t\tif(output){\n\t\t\treturn output[propName] ? output[propName] : defaultValue;\n\t\t}\n\t\treturn defaultValue;\n\t},\n\n\t/**\n\t * Check if the client web browser can render WebGL 3D content.\n\t * \n\t * @private\n\t * @param  {boolean} return_context flag making this method return the canvas object instead of true\n\t * @return {boolean} true if the client is WebGL enabled, false otherwise\n\t */\n\thasWebGL : function(return_context)\n\t{\n\t\tif (!!window.WebGLRenderingContext) {\n\t\t\tvar canvas = document.createElement(\"canvas\"),\n\t\t\t\tnames = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"],\n\t\t\tcontext = false;\n\t\n\t\t\tfor(var i=0;i<4;i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcontext = canvas.getContext(names[i]);\n\t\t\t\t\tif (context && typeof context.getParameter == \"function\") {\n\t\t\t\t\t\t// WebGL is enabled\n\t\t\t\t\t\tif (return_context) {\n\t\t\t\t\t\t\t// return WebGL object if the function's argument is present\n\t\t\t\t\t\t\treturn {name:names[i], gl:context};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// else, return just true\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\n\t\t\t// WebGL is supported, but disabled\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// WebGL not supported\n\t\treturn false;\n\t}\n\n};\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n * \n * @private\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements(){\n\tvar numErrors = 0;\n\n\tif(!global.window || !window.indexedDB){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"T3D persistant storing and loading requires indexedDB support.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif(typeof DataStream === \"undefined\"){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"T3D core functionality requires DataStream library.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif(typeof THREE === \"undefined\"){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"T3D mesh generation requires three.js library.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif(numErrors<1){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_MESSAGE,\n\t\t\t\"Tyria 3D API v\"+T3D.version+\" initialized.\"\n\t\t);\n\t}\n\n\treturn numErrors;\n}\n\n/**\n * Performs a quick and dirty check to find what chunk name definitions \n * appear multiple times in th formats array. Note that anything that\n * appears more than 2 times wil get a too hight value due to the \n * algorithm being... incorrect.\n *\n * @private\n * @return {Object} An object mapping duplicate chunk definition names.\n * to the number of apperances.\n */\nfunction findDuplicateChunkDefs(){\n\tvar dups = {};\n\tT3D.formats.forEach(\n\t\tfunction(f1){\n\n\t\t\tT3D.formats.forEach(\n\t\t\t\tfunction(f2){\n\t\t\t\t\tif(f2.name == f1.name && f2 !== f1){\n\t\t\t\t\t\tif(dups[f1.name]){\n\t\t\t\t\t\t\tdups[f1.name]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdups[f1.name]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t);\n\treturn dups\n}\n\n/// Library checks requirements on startup\ncheckRequirements();\n","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require('../format/file/GW2File');\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n * \n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n * \n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n * \n * \n * \n * \n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nvar DataRenderer = function(localReader, settings, context, logger) {\n\n\t/// Just storing parameters\n\tthis.localReader = localReader;\n\tthis.settings = settings;\n\tif(!settings){\n\t\tsettings = {};\n\t}\n\tthis.context = context;\n\tthis.context[this.constructor.name] = {};\n\n\tif(logger)\n\t\tthis.logger = logger;\n\telse\n\t\tthis.logger = T3D.Logger;\t\n}\n\n/**\n * Gets the output value object for a specified class within the context.\n * \n * @param  {Class} otherClass The class to fetch the output value object for.\n * If not specified the class of this instance will be used.\n * @return {Object}            The output value object for this class within the context.\n */\nDataRenderer.prototype.getOutput = function(otherClass){\n\treturn this.context[otherClass ? otherClass.name : this.constructor.name];\n}\n\n/**\n * Basic rendering of unknown files. Output fileds generated:\n *\n * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n * \n * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n * \n * - *rawString* A string representation of the rawData\n * \n * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n * image. Only set if the loaded file was a texture.\n * \n * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nDataRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\t\n\tthis.localReader.loadFile(this.settings.id, function(inflatedData){\n\n\t\t/// Set fileId so callers can identify this VO\t\t\n\t\tself.getOutput().fileId = self.settings.id;\n\n\t\t/// Share inflated data\n\t\tself.getOutput().rawData = inflatedData;\n\n\t\t/// Construct raw string\n\t\tvar uarr = new Uint8Array(inflatedData);\n\t\tvar rawStrings = [], chunksize = 0xffff;\n\t\tvar len = Math.min(uarr.length,10000);\n\n\t\t// There is a maximum stack size. We cannot call String.fromCharCode with as many arguments as we want\n\t\tfor (var i = 0; i * chunksize < len; i++){\n\t\t\trawStrings.push(String.fromCharCode.apply(null, uarr.subarray(i * chunksize, (i + 1) * chunksize)));\n\t\t}\n\n\t\tif(len<uarr.length){\n\t\t\trawStrings.push(\"T3D Ignored the last \"+(uarr.length-len)+\" bytes when generating this raw output\");\n\t\t}\n\n\t\tself.getOutput().rawString = rawStrings.join();\n\n\n\n\t\t/// Check if this is an PF or ATEX file\n\t\t// Binareis are MZ\n\t\tvar ds = new DataStream(inflatedData);\n\t\tvar first4 = ds.readCString(4);\n\n\t\t/// Do special stuff for different fcc signatures\n\t\t/// \n\t\t/// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\n        /// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\n\t\t/// \n\t\tif( first4 == \"ATEX\" || first4 == \"ATEC\" ||\n\t\t\tfirst4 == \"ATEP\" || first4 == \"ATET\" || \n\t\t\tfirst4 == \"ATEU\" || first4 == \"ATTX\" ){\n\n\t\t\t/// TODO: MOVE TO GW2 texture file!!\n\t\t\t/// Load file using LocalReader.\n\t\t\tself.localReader.loadTextureFile(self.settings.id,\n\t\t\t\tfunction(inflatedData, dxtType, imageWidth, imageHeigth){\n\t\t\t\t\t\n\t\t\t\t\t/// Create image using returned data.\n\t\t\t\t\tvar image = {\n\t\t\t\t\t\tdata   : new Uint8Array(inflatedData),\n\t\t\t\t\t\twidth  : imageWidth,\n\t\t\t\t\t\theight : imageHeigth\n\t\t\t\t\t};\n\n\t\t\t\t\tself.getOutput().image = image;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t\telse if(first4.indexOf(\"PF\") == 0){\n\t\t\tself.getOutput().file = new GW2File(ds,0);\n\t\t\tcallback();\n\t\t}\n\t\telse{\n\t\t\tself.getOutput().file = null;\n\t\t\tcallback();\n\t\t}\n\n\t});\t\n}\n\nmodule.exports = DataRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n * \n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction EnvironmentRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\n\tthis.mapFile = this.settings.mapFile;\n\n\tthis.getMat = function(tex){\n\t\treturn new THREE.MeshBasicMaterial({\n\t\t\tmap: tex,\n\t\t\tside: THREE.BackSide,\n\t\t\tfog: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t};\n\n\tthis.loadTextureWithFallback = function(targetMatIndices, materialArray, filename, fallbackFilename, hazeColorAsInt){\n\t\tvar self = this;\n\t\t\n\t\tfunction writeMat(mat){\n\t\t\ttargetMatIndices.forEach(function(i){\n\t\t\t\tmaterialArray[i] = mat; \n\t\t\t});\n\t\t}\n\n\t\tfunction loadFallback(){\n\t\t\tvar mat = self.getMat(\n\t\t\t\tnew THREE.TextureLoader().load(fallbackFilename)\n\t\t\t);\n\n\t\t\twriteMat(mat);\n\t\t}\n\n\t\tfunction errorCallback(){\n\t\t\tsetTimeout(loadFallback, 1);\n\t\t}\n\n\t\tvar mat = self.getMat(\n\t\t\tRenderUtils.loadLocalTexture(\n\t\t\t\tlocalReader,\n\t\t\t\tfilename,\n\t\t\t\tnull, hazeColorAsInt,\n\t\t\t\terrorCallback )\n\t\t);\n\n\t\twriteMat(mat);\t\t\t\n\t}\n\n\tthis.getHazeColor = function(environmentChunkData){\n\t\tvar hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n\t\tif(!hazes || hazes.length<=0){\n\t\t\treturn [190, 160, 60];\n\t\t}\n\t\telse{\n\t\t\treturn hazes[0].farColor;\n\t\t}\n\t};\n\n\tthis.parseLights = function(environmentChunkData){\n\t\tvar self = this;\n\n\t\t/// Set up output array\n\t\tself.getOutput().lights = [];\n\n\t\tvar lights = environmentChunkData ? environmentChunkData.dataGlobal.lighting : [{\n\t\t\tlights:[],\n\t\t\tbacklightIntensity:1.0,\n\t\t\tbacklightColor:[255,255,255]\n\t\t}];\n\n\t\tvar ambientLight;\n\n\t\t//var light = lights[0];\n\t\t//\n\t\tvar hasLight = false;\n\t\tlights.forEach(function(light, idx){\n\n\t\t\tif(hasLight)\n\t\t\t\treturn;\n\n\t\t\t/// Directional lights\n\t\t\tvar sumDirLightIntensity = 0;\n\n\t\t\t\n\t\t\tlight.lights.forEach(function(dirLightData,idx){\n\n\t\t\t\thasLight = true;\n\t\t\t\t\n\t\t\t\tvar color = new THREE.Color(\n\t\t\t\t\tdirLightData.color[2]/255.0,\n\t\t\t\t\tdirLightData.color[1]/255.0,\n\t\t\t\t\tdirLightData.color[0]/255.0\n\t\t\t\t);\n\n\t\t\t\tvar directionalLight = new THREE.DirectionalLight( color.getHex(), dirLightData.intensity );\n\t\t\t\t\n\t\t\t\tdirectionalLight.position.set(\n\t\t\t\t\t-dirLightData.direction[0],\n\t\t\t\t\tdirLightData.direction[2],\n\t\t\t\t\tdirLightData.direction[1]\n\t\t\t\t).normalize();\n\t\t\t\t\n\t\t\t\tsumDirLightIntensity += dirLightData.intensity;\n\n\t\t\t\tself.getOutput().lights.push(directionalLight);\n\n\t\t\t});// END for each directional light in light\n\n\n\t\t\t/// Add some random directional lighting if there was no, in order to se SOME depth on models\n\t\t\tif(!light.lights || light.lights.length==0){\t\t\n\n\t\t\t\tvar directions = [\n\t\t\t\t\t[0,1,0,.3],\t\t\t\t\t\n\t\t\t\t\t[1,2,1,.3],\n\t\t\t\t\t[-1,-2,-1,.3]\n\t\t\t\t];\n\n\t\t\t\tdirections.forEach(function(lightDir){\n\n\t\t\t\t\tvar color = new THREE.Color(1,1,1);\n\t\t\t\t\tvar intensity = lightDir[3];\n\t\t\t\t\tvar directionalLight = new THREE.DirectionalLight( color.getHex(), intensity );\n\t\t\t\t\t\n\t\t\t\t\tdirectionalLight.position.set(lightDir[0],lightDir[1],lightDir[2]).normalize();\n\t\t\t\t\t\n\t\t\t\t\tsumDirLightIntensity += intensity;\n\n\t\t\t\t\tself.getOutput().lights.push(directionalLight);\n\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\n\n\t\t\t/// Ambient light\n\t\t\t//light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity; \n\t\t\tlight.backlightIntensity =  light.backlightIntensity; \n\t\t\tvar color = new THREE.Color(\n\t\t\t\tlight.backlightIntensity * (255.0-light.backlightColor[2])/255.0,\n\t\t\t\tlight.backlightIntensity * (255.0-light.backlightColor[1])/255.0,\n\t\t\t\tlight.backlightIntensity * (255.0-light.backlightColor[0])/255.0\n\t\t\t);\n\n\t\t\tambientLight = new THREE.AmbientLight(color);\n\n\t\t})// END for each light in lighting\n\n\t\tvar ambientTotal = 0;\n\t\tif(ambientLight){\n\t\t\tambientTotal = ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n\t\t\tthis.getOutput().lights.push(ambientLight);\n\t\t}\n\n\t\t/// Parsing done, set hasLight flag and return\n\t\tthis.getOutput().hasLight = hasLight || ambientTotal>0;\t\t\n\t};\n\n\tthis.parseSkybox = function(environmentChunkData, parameterChunkData, hazeColorAsInt){\n\n\t\t/// set up output array\n\t\tthis.getOutput().skyElements = [];\n\t\t\n\t\t/// Grab sky texture.\n\t\t/// index 0 and 1 day\n\t\t/// index 2 and 3 evening\n\t\tvar skyModeTex = this.environmentChunkData && this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n\t\t/// Fallback skyboxfrom dat.\n\t\tif(!skyModeTex){\n\t\t\tskyModeTex = {\n\t\t\t\ttexPathNE:1930687,\n\t\t\t\ttexPathSW:193069,\n\t\t\t\ttexPathT:193071\n\t\t\t}\n\t\t}\n\n\t\t/// Calculate bounds\n\t\tvar bounds = parameterChunkData.rect;\n\t\tvar mapW = Math.abs( bounds.x1 -bounds.x2 );\n\t\tvar mapD = Math.abs( bounds.y1 -bounds.y2 );\n\t\tvar boundSide = Math.max( mapW, mapD );\n\n\t\tvar materialArray = [];\n\n\t\t/// Load skybox textures, fallback to hosted png files.\n\t\tthis.loadTextureWithFallback([1,4], materialArray, skyModeTex.texPathNE + 1, \"img/193068.png\", hazeColorAsInt);\n\t\tthis.loadTextureWithFallback([0,5], materialArray, skyModeTex.texPathSW + 1, \"img/193070.png\", hazeColorAsInt);\n\t\tthis.loadTextureWithFallback([2], materialArray, skyModeTex.texPathT + 1, \"img/193072.png\", hazeColorAsInt);\n\t\tmaterialArray[3] = new THREE.MeshBasicMaterial({visible:false});\n\n\n\t\t/// Create skybox geometry\n\t\tvar boxSize = 1024;\t\t\n\t\tvar skyGeometry = new THREE.BoxGeometry( boxSize, boxSize/2 , boxSize ); //Width Height Depth\n\n\t\t/// Ugly way of fixing UV maps for the skybox (I think)\n\t\tskyGeometry.faceVertexUvs[0].forEach(function(vecs, idx){\n\n\t\t\tvar face = Math.floor(idx/2);\n\n\t\t\t// PX NX\n\t\t\t// PY NY\n\t\t\t// PZ NZ\n\n\t\t\t/// PX - WEST \tNX - EAST\n\t\t\tif(face == 0 || face == 1){\n\t\t\t\tvecs.forEach(function(vec2){\n\t\t\t\t\tvec2.x = 1 - vec2.x;\t\n\t\t\t\t\tvec2.y /= 2.0;\t\n\t\t\t\t\tvec2.y += .5;\t\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/// NZ - SOUTH \tPZ - NORTH\n\t\t\telse if(face == 5 || face == 4){\n\t\t\t\tvecs.forEach(function(vec2){\n\t\t\t\t\tvec2.y /= -2.0;\t\n\t\t\t\t\tvec2.y += .5;\t\n\t\t\t\t});\n\t\t\t}\n\n\t\t\telse{\n\t\t\t\tvecs.forEach(function(vec2){\n\t\t\t\t\tvec2.x = 1 - vec2.x;\t\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\t\tskyGeometry.uvsNeedUpdate = true;\n\t\t\n\t\t/// Generate final skybox\n\t\tvar skyBox = new THREE.Mesh( skyGeometry, materialArray );\n\n\t\t/// Put horizon in camera center\n\t\tskyBox.translateY(boxSize/4);\n\t\t//skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\t\t\n\t\t/// Write to output\n\t\tthis.getOutput().skyElements.push(skyBox);\n\t};\n}\n\n\n/// DataRenderer inheritance:\nEnvironmentRenderer.prototype = Object.create(DataRenderer.prototype);\nEnvironmentRenderer.prototype.constructor = EnvironmentRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n * - *skyElements* A textured THREE.Mesh skybox.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nEnvironmentRenderer.prototype.renderAsync = function(callback){\n\n\tvar environmentChunkData = this.mapFile.getChunk(\"env\").data;\n\tvar parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n\t/// Set renderer clear color from environment haze\n\tvar hazeColor = this.getHazeColor(environmentChunkData);\n\tvar hazeColorAsInt =  hazeColor[2]*256*256+hazeColor[1]*256+hazeColor[0];\n\tthis.getOutput().hazeColor = hazeColor;\n\n\t/// Add directional lights to output. Also write hasLight flag\n\tthis.parseLights(environmentChunkData);\n\n\t/// Generate skybox\n\tthis.parseSkybox(environmentChunkData, parameterChunkData, hazeColorAsInt);\n\n\t/// All parsing is synchronous, just fire callback\n\tcallback();\n};\n\t\n\nmodule.exports = EnvironmentRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n * \n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction HavokRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\n\tthis.mapFile = this.settings.mapFile;\n\n\tthis.lastP = -1;\n\tthis.seed = 1;\n\tthis.meshes = [];\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {Function} callback         [description]\n\t * @async\n\t */\n\tthis.renderModels = function(models, title, callback){\n\t\tvar mat;\n\t\tif(this.settings && this.settings.visible){\n\t\t\tmat = new THREE.MeshNormalMaterial( { side: THREE.DoubleSide } ); \n\t\t}\n\t\telse{\n\t\t\tmat = new THREE.MeshBasicMaterial( { visible: false } );\t\t\t\n\t\t}\n\n\t\tthis.parseAllModels(models, mat, title, 200, 0, callback);\n\t}\n\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} animation  [description]\n\t * @param  {*} collisions [description]\n\t * @return {*}            [description]\n\t */\n\tthis.getCollisionsForAnimation = function(animation, collisions){\n\t\tvar ret = [];\n\t\t\n\t\tfor (var i = 0; i < animation.collisionIndices.length; i++) {\n\t\t\tvar index = animation.collisionIndices[i];\n\t\t\tvar collision = collisions[ index ];\n\t\t\tcollision.index = index;\n\t\t\tret.push( collision );\n\t\t}\n\t\t\n\t\treturn ret;\n\t};\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} models       [description]\n\t * @param  {*} mat       [description]\n\t * @param  {*} title     [description]\n\t * @param  {*} chunkSize [description]\n\t * @param  {*} offset    [description]\n\t * @return {*} callback          [description]\n\t * @async\n\t */\n\tthis.parseAllModels = function(models, mat, title, chunkSize, offset, callback){\n\t\tvar i = offset;\t\t\n\n\t\tfor(; i < offset+chunkSize && i < models.length; i++){\n\t\t\t\n\t\t\tvar p = Math.round(i*100/ models.length );\n\t\t\tif( p != this.lastP){\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\t\"Loading Collision Models (\"+title+\")\",\n\t\t\t\t\tp\n\t\t\t\t);\n\t\t\t\tthis.lastP = p;\n\t\t\t}\t\n\t\t\n\t\t\t/// Get animation object\n\t\t\tvar animation =  this.animationFromGeomIndex(\n\t\t\t\tmodels[i].geometryIndex,\n\t\t\t\tthis.geometries,\n\t\t\t\tthis.animations\n\t\t\t);\n\t\t\t\n\t\t\tvar collisions = this.getCollisionsForAnimation( animation, this.havokChunkData.collisions);\n\t\t\t\n\t\t\tfor(var j=0; j< collisions.length; j++){\n\t\t\t\tvar collision = collisions[j];\t\t\t\n\t\t \t\tthis.renderMesh( collision, models[i], mat );\n\t\t\t}\n\t\t}\n\n\t\tif(i<models.length){\n\t\t\twindow.setTimeout(\n\t\t\t\tthis.parseAllModels.bind(this, models, mat, title, chunkSize, offset+chunkSize, callback),\n\t\t\t\t10 /*time in ms to next call*/\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} propGeomIndex [description]\n\t * @param  {*} geometries    [description]\n\t * @param  {*} animations    [description]\n\t * @return {*}               [description]\n\t */\n\tthis.animationFromGeomIndex = function(propGeomIndex, geometries, animations){\n\t\t\n\t\t// geometries is just list of all geometries.animations[end] for now\n\t\tvar l = geometries[propGeomIndex].animations.length;\n\t\t\n\t\treturn animations[ geometries[propGeomIndex].animations[l-1] ];\n\t\t//return animations[ geometries[propGeomIndex].animations[0] ];\n\t};\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} collision [description]\n\t * @param  {*} model     [description]\n\t * @param  {*} mat       [description]\n\t * @return {*}           [description]\n\t */\n\tthis.renderMesh = function( collision, model, mat ){\n\t    \n\t    var pos = model.translate;\n\t    var rot = model.rotate;\n\t    var scale = 32 * model.scale;    \n\t    \n\t    /// Generate mesh\n\t    var mesh = this.parseHavokMesh(collision, mat);\n\t    \n\t    /// Position mesh\n\t    /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n\t    mesh.position.set(pos[0], -pos[2], -pos[1]);    \n\t    \n\t    /// Scale mesh\n\t    if(scale)\n\t    \tmesh.scale.set( scale, scale, scale );\n\n\t    /// Rotate mesh\n\t    if(rot){\n\t    \tmesh.rotation.order = \"ZXY\";\n\n\t    \t// [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"], \n\t    \tmesh.rotation.set(rot[0], -rot[2], -rot[1]);\n\t    }\n\t    \t\n\t\t/// Add mesh to scene and collisions\n\t\tthis.getOutput().meshes.push(mesh);\n\t};\n\n\n\t/**\n\t * TODO\n\t * \n\t * @return {*} [description]\n\t */\n\tthis.seedRandom = function(){\n\t    var x = Math.sin(this.seed++) * 10000;\n\t    return x - Math.floor(x);\n\t};\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} collision [description]\n\t * @param  {*} mat       [description]\n\t * @return {*}           [description]\n\t */\n\tthis.parseHavokMesh = function(collision, mat){\n\t\t\n\t\tvar index = collision.index;\n\n\t\tif(!this.meshes[index]){\n\n\t\t\tvar geom = new THREE.Geometry();\n\t\t\t\n\t\t\t/// Pass vertices\t    \t\t\n\t\t\tfor(var i=0; i<collision.vertices.length; i++){\n\t\t\t\tvar v=collision.vertices[i];\n\t\t\t\t//\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n\t\t\t\tgeom.vertices.push( new THREE.Vector3(v[0] , v[2] , -v[1] ) );\n\t\t\t}\t    \t\t\n\t\t\t\t\n\t\t\t/// Pass faces\n\t\t\tfor(var i=0; i<collision.indices.length; i+=3){\n\n\t\t\t\tvar f1=collision.indices[i];\n\t\t\t\tvar f2=collision.indices[i+1];\n\t\t\t\tvar f3=collision.indices[i+2];\n\n\t\t\t\tif( f1<=collision.vertices.length &&\n\t\t\t\t\tf2<=collision.vertices.length &&\n\t\t\t\t\tf3<=collision.vertices.length){\n\t\t\t\t\tgeom.faces.push( new THREE.Face3( f1, f2, f3 ) );\n\t\t\t\t}\n\t   \t\t\telse{\n\t   \t\t\t\tthis.logger.log(\n\t   \t\t\t\t\tT3D.Logger.TYPE_ERROR,\n\t   \t\t\t\t\t\"Errorus index in havok model geometry.\"\n   \t\t\t\t\t);\n\t   \t\t\t}\n\t\t\t}\n\n\t\t\t/// Prepare geometry and pass new mesh\n\t\t\tgeom.computeFaceNormals();\n\t\t\t//geom.computeVertexNormals();\n\t\t\t\n\t\t\tthis.meshes[index]= new THREE.Mesh( geom, mat ); \n\t\t\t\n\t\t\treturn this.meshes[index];\n\t\t}\n\t\telse{\n\t\t\treturn this.meshes[index].clone();\n\t\t}\n\t};\n\n};\n\n\n/// DataRenderer inheritance:\nHavokRenderer.prototype = Object.create(DataRenderer.prototype);\nHavokRenderer.prototype.constructor = HavokRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *boundingBox* Array of values describing the bounding box of all collision.\n * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nHavokRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t// TODO:The design of this method pretty much requires one instance\n\t// of the class per parallel async render. Should probably fix this\n\t// at some point...\n\t\n\t/// Get required chunks\n\tthis.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n    /// Set static bounds to the bounds of the havk models\n    this.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\t\n\t/// Clear old meshes\n\tthis.meshes = [];\n\n\t/// Set up output array\n\tthis.getOutput().meshes = [];\n\n\t/// Grab model raw data from the chunk.\n\t/// Add missing scale value to obs models.\n\tvar propModels = this.havokChunkData.propModels;\n\tvar zoneModels = this.havokChunkData.zoneModels;\n\tvar obsModels = this.havokChunkData.obsModels;\n\tobsModels.forEach(function(mdl){\n\t\tmdl.scale = 1;\n\t});\n\n\t/// Store geoms and animations from the file in hte instance so we don't\n\t/// have to pass them arround too much. (fix this later)\n\tthis.geometries = this.havokChunkData.geometries;\n\tthis.animations = this.havokChunkData.animations;\t\t\n\t\n\t/// Render \"prop\", \"zone\" and \"obs\" models in that order.\n\tvar renderPropModelsCB = function(){\n\t\tself.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n\t};\n\tvar renderZoneModelsCB = function(){\n\t\tself.renderModels(obsModels, \"obs\", callback);\n\t};\n\tself.renderModels(propModels, \"prop\", renderPropModelsCB);\n\n\t\n}\n\nmodule.exports = HavokRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates property models for a map.\n * \n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction PropertiesRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\tthis.mapFile = this.settings.mapFile;\n}\n\n/// DataRenderer inheritance:\nPropertiesRenderer.prototype = Object.create(DataRenderer.prototype);\nPropertiesRenderer.prototype.constructor = PropertiesRenderer;\n\n/**\n * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nPropertiesRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\tself.getOutput().meshes = [];\n\n\tvar propertiesChunkData =  this.mapFile.getChunk(\"prp2\").data;\n\n\tif(!propertiesChunkData){\n\t\trenderCallback();\n\t\treturn;\n\t}\n\n\tvar props = propertiesChunkData.propArray;\n\tvar animProps =propertiesChunkData.propAnimArray;\n\tvar instanceProps = propertiesChunkData.propInstanceArray;\n\tvar metaProps = propertiesChunkData.propMetaArray;\n\n\t/// Concat all prop types\n\tprops = props\n\t\t.concat(animProps)\n\t\t.concat(instanceProps)\n\t\t.concat(metaProps);\n\n\t/// Create mesh cache\n\tself.meshCache = {};\n\tself.textureCache = {};\n\n\t// For now, we'll do all load in serial\n\t// TODO: load unique meshes and textures in parallell (asynch), then render!\n\tvar lastPct = -1;\n\n\tvar renderIndex = function(idx){\n\n\t\tif(idx>= props.length){\n\n\t\t\t/// Empty mesh cache\n\t\t\tself.meshCache = {};\n\t\t\tself.textureCache = {};\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t\tvar pct = Math.round(1000.0*idx / props.length);\n\t\tpct/=10.0;\n\t\t\n\t\t/// Log progress\n\t\tif(lastPct!=pct){\n\t\t\tvar pctStr = pct +\n\t\t\t\t( pct.toString().indexOf(\".\")<0 ? \".0\":\"\" );\n\n\t\t\tself.logger.log(\n\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\"Loading 3D Models (Props)\", pctStr\n\t\t\t);\n\t\t\tlastPct = pct;\n\t\t}\n\n\t\t/// Read prop at index.\n\t\tvar prop = props[idx];\t\t\t\t\t\t\t\t\n\n\t    /// Adds a single mesh to a group.\n\t\tvar addMeshToLOD = function(mesh, groups, lod, prop, needsClone){\n\n\t\t\t/// Read lod distance before overwriting mesh variable\n\t\t    var lodDist = prop.lod2 != 0 ? prop.lod2 : mesh.lodOverride[1];\n\n\t\t    /// Read flags before overwriting mesh variable\n\t    \tvar flags = mesh.flags;\n\n\t    \t/// Mesh flags are 0 1 4\n\t    \t/// For now, use flag 0 as the default level of detail\n\t    \tif(flags==0)\n\t    \t\tlodDist=0;\n\t    \t\n\t    \t/// Create new empty mesh if needed\n\t    \tif(needsClone){\n\t    \t\tmesh = new THREE.Mesh( mesh.geometry, mesh.material );\n\t    \t}\n\n\t    \tmesh.updateMatrix();\n\t\t\tmesh.matrixAutoUpdate = false;\n\n\t    \t// Find group for this LOD distance\n\t    \tif(groups[lodDist]){\n\t    \t\tgroups[lodDist].add(mesh);\n\t    \t}\n\t    \t// Or create LOD group and add to a level of detail\n\t    \t// WIP, needs some testing!\n\t    \telse{\n\t    \t\tvar group = new THREE.Group();\n\t    \t\tgroup.updateMatrix();\n\t\t\t\tgroup.matrixAutoUpdate = false;\n\t    \t\tgroup.add(mesh);\n\t    \t\tgroups[lodDist] = group;\n\t    \t\tlod.addLevel(group,lodDist);\n\t    \t}\n\n\t    \treturn lodDist;\n\t    }\n\n\t    /// Adds array of meshes to the scene, also adds transform clones\n\t\tvar addMeshesToScene = function(meshArray, needsClone, boundingSphere){\n\t\t\t\n\t\t    ///Add original \n\n\t\t    /// Make LOD object and an array of groups for each LOD level\n\t\t    var groups = {};\n\t\t    var lod = new THREE.LOD();\n\n\t\t    /// Each mesh is added to a group corresponding to its LOD distane\n\t\t    var maxDist = 0;\n\t\t    meshArray.forEach(function(mesh){\n\t\t    \tmaxDist = Math.max( maxDist, addMeshToLOD(mesh,groups,lod,prop,needsClone) );\n\t    \t});\n\n\t    \t/// Add invisible level (the raycaster crashes on lod without any levels)\n\t    \tlod.addLevel(new THREE.Group(),100000);\n\n\t\t    /// Set position, scale and rotation of the LOD object\n\t\t\tif(prop.rotation){\n\t\t    \tlod.rotation.order = \"ZXY\";\n\t\t    \t//[\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n\t\t    \tlod.rotation.set(prop.rotation[0], -prop.rotation[2], -prop.rotation[1]);\n\t\t    }\n\t\t    lod.scale.set( prop.scale, prop.scale, prop.scale );\n\t\t    lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\t\t   \t\n\n\t\t   \tlod.boundingSphereRadius = ( boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) * prop.scale;\n\n\t\t    lod.updateMatrix();\n\t\t    lod.matrixAutoUpdate = false;\n\n\t\t    /// Show highest level always\n\t\t    //lod.update(lod);\n\n\t    \t//Add LOD containing mesh instances to scene\n\t    \tself.getOutput().meshes.push(lod);\n\t    \t\t\t\t    \n\t\t    // Add one copy per transform, needs to be within it's own LOD\n\t\t    if(prop.transforms){\n\n\t\t    \tprop.transforms.forEach(function(transform){\n\t\t    \t\t\n\t\t    \t\t/// Make LOD object and an array of groups for each LOD level\n\t\t    \t\tvar groups = {};\n\t\t    \t\tvar lod = new THREE.LOD();\n\n\t\t    \t\t/// Each mesh is added to a group corresponding to its LOD distane\n\t\t    \t\tvar maxDist = 0;\n\t\t\t    \tmeshArray.forEach(function(mesh){\n\t\t\t    \t\tmaxDist = Math.max( maxDist, addMeshToLOD(mesh,groups,lod,prop,true) );\n\t\t\t    \t});\n\n\t\t\t    \t/// Add invisible level\n\t    \t\t\t//lod.addLevel(new THREE.Group(),10000);\n\n\t\t\t    \t/// Set position, scale and rotation of the LOD object\n\t\t\t\t\tif(transform.rotation){\n\t\t\t\t    \tlod.rotation.order = \"ZXY\";\n\t\t\t\t    \tlod.rotation.set(transform.rotation[0], -transform.rotation[2], -transform.rotation[1]);\n\t\t\t\t    }\n\t\t\t\t    lod.scale.set( transform.scale, transform.scale, transform.scale );\n\t\t\t\t    lod.position.set(transform.position[0], -transform.position[2], -transform.position[1]);\n\n\t\t\t\t\tlod.updateMatrix();\n\t\t    \t\tlod.matrixAutoUpdate = false;\n\n\t\t    \t\tlod.boundingSphereRadius = ( boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) * prop.scale;\n\n\t\t\t\t\t/// Show highest level always\n\t\t    \t\tlod.update(lod);\n\n\t\t\t    \t/// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n\t\t\t    \tself.getOutput().meshes.push(lod);\n\t\t\t    });\n\t\t    }\n\t\t}\n\n\t\t/// Get meshes\n\t\tvar showUnmaterialed = false;\n\t\tRenderUtils.getMeshesForFilename(prop.filename, prop.color, self.localReader, self.meshCache, self.textureCache, showUnmaterialed,\n\t\t\tfunction(meshes, isCached, boundingSphere){\n\t\t\t\n\t\t\t\tif(meshes){\n\t\t\t\t\taddMeshesToScene(meshes, isCached, boundingSphere);\n\t\t\t\t}\n\n\t\t\t\t/// Render next prop\n\t\t\t\trenderIndex(idx+1);\n\t\t\t}\n\t\t);\n\n\t\t\n\n\t};\n\n\t/// Start serial loading and redering. (to allow re-using meshes and textures)\n\trenderIndex(0);\n}\n\n\n/**\n * TODO: write description. Used for export feature\n * @param  {Function} callback [description]\n * @return {*}            [description]\n */\nPropertiesRenderer.prototype.getFileIdsAsync = function(callback){\n\tvar fileIds = [];\n\n\tvar propertiesChunkData =  this.mapFile.getChunk(\"prp2\").data;\n\n\tvar props = propertiesChunkData.propArray;\n\tvar animProps = propertiesChunkData.propAnimArray;\n\tvar instanceProps = propertiesChunkData.propInstanceArray;\n\tvar metaProps = propertiesChunkData.propMetaArray;\n\n\tprops = props\n\t\t.concat(animProps)\n\t\t.concat(instanceProps)\n\t\t.concat(metaProps);\n\n\tvar getIdsForProp = function(idx){\n\n\t\tif(idx>=props.length){\n\t\t\tcallback(fileIds);\n\t\t\treturn;\n\t\t}\n\n\t\tif(idx%100==0){\n\n\t\t\tthis.logger.log(\n\t\t\t\tT3D.Logger.TYPE_MESSAGE,\n\t\t\t\t\"getting ids for entry\",idx,\"of\",props.length\n\t\t\t);\n\t\t}\n\n\t\tvar prop = props[idx];\n\t\tUtils.getFilesUsedByModel(\n\t\t\tprop.filename,\n\t\t\tlocalReader,\n\t\t\tfunction(propFileIds){\n\t\t\t\tfileIds = fileIds.concat(propFileIds);\n\t\t\t\tgetIdsForProp(idx+1);\n\t\t\t}\n\t\t);\n\n\t};\n\n\tgetIdsForProp(0);\n};\n\nmodule.exports = PropertiesRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n * \n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction SingleModelRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n}\n\n\n/// DataRenderer inheritance:\nSingleModelRenderer.prototype = Object.create(DataRenderer.prototype);\nSingleModelRenderer.prototype.constructor = SingleModelRenderer;\n\n\n/**\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nSingleModelRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t/// Get file id\n\tvar fileId = this.settings.id;\n\tvar showUnmaterialed = true;\n\n\t/// Load the model file\n\tvar meshCache = {};\n\tvar textureCache = {};\n\n\t/// Set up output array\n\tself.getOutput().meshes = [];\n\n\tRenderUtils.getMeshesForFilename(fileId, 0x00ff00, self.localReader, meshCache, textureCache, showUnmaterialed,\n\t\tfunction(meshes, isCached, boundingSphere){\n\t\t\n\t\t\tif(meshes){\n\t\t\t\tmeshes.forEach(function(mesh){\n\t\t\t\t\tmesh.boundingSphere = boundingSphere;\n\t\t\t\t\tself.getOutput().meshes.push(mesh);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/// Fire callback after all meshes have been added.\n\t\t\tmeshCache = {};\n\t\t\tcallback();\n\t\t}\n\t);\n\n}\n\nmodule.exports = SingleModelRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n * \n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction StringRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n}\n\n\n/// DataRenderer inheritance:\nStringRenderer.prototype = Object.create(DataRenderer.prototype);\nStringRenderer.prototype.constructor = StringRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n * a given string was found, and a \"value\"-property specigying the string value.\n *\n * - *language* An integer specifing the language of the loaded file.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nStringRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t/// Get file id\n\tvar fileId = this.settings.id;\n\tvar showUnmaterialed = true;\n\n\t/// Load the string file\n\n\t/// Set up output array\n\tthis.getOutput().strings = [];\n\n\tthis.localReader.loadFile(this.settings.id, function(inflatedData){\n\t\tvar ds = new DataStream(inflatedData);\n\t\tvar end = ds.byteLength -2;\n\n    \t/// skip past fcc\n    \tds.seek(4);\n\n    \tvar entryHeaderDef =\n\t\t[\n\t\t\t\"size\", \"uint16\",\n\t\t\t\"decryptionOffset\", \"uint16\",\n\t\t\t\"bitsPerSymbol\", \"uint16\"\n\t\t];\n\n\t\tvar entryIndex = 0;\n\n    \twhile ( end - ds.position > 6) {\n\t        \t        \n\t        var entry = ds.readStruct(entryHeaderDef);\n\t        entry.size -= 6;\n\n\t        if(entry.size > 0){\n\n\n\t        \tvar isEncrypted = entry.decryptionOffset != 0 || entry.bitsPerSymbol != 0x10;\n\n\t        \t/// UTF-16\n\t        \tif( !isEncrypted ){\n\t        \t\tvar value =  ds.readUCS2String(entry.size/2);\n\t        \t\tself.getOutput().strings.push({\n\t        \t\t\tvalue:value,\n\t        \t\t\trecid:entryIndex\n\t        \t\t});\n\t        \t}\n\n\t        \t/// Other... ignored\n\t        \telse{\n\n\t        \t}\n\t        }\n\n\t        entryIndex++;        \n\t    }\n\n\n\t\tds.seek(ds.byteLength - 2);\n    \tself.getOutput().language = ds.readUint16();\n\t\tcallback();\n\t});\n\n\n}\n\nmodule.exports = StringRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require('./DataRenderer');\nconst GW2File = require(\"../format/file/GW2File.js\"); \n\nconst TerrainShader = require(\"../util/TerrainShader.js\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n * \n * Requires a context previously populated by a \n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n * \n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction TerrainRenderer(localReader, mapFile, settings, context, logger){\n\tDataRenderer.call(this, localReader, mapFile, settings, context, logger);\n\tthis.mapFile = this.settings.mapFile;\n\n\tthis.drawWater = function(rect){\n\t\t\n\t\t/// Add Water\n\t\tvar material = material || new THREE.MeshBasicMaterial(\n\t\t\t{\n\t\t\t\tcolor: 0x5bb1e8,\n\t\t\t\twireframe:false,\n\t\t\t \topacity: 0.35\n\t\t\t}\n\t\t);\n\n\t\tmaterial.transparent = true;\n\t\treturn RenderUtils.renderRect(rect, 0, material);\n\t}\n\n\tthis.parseNumChunks = function(terrainData){\n\t\tterrainData.numChunksD_1 = Math.sqrt(\n\t\t\tterrainData.dims[0] *\n\t\t\tterrainData.chunkArray.length /\n\t\t\tterrainData.dims[1]\n\t\t);\n\t\tterrainData.numChunksD_2 =\n\t\t\tterrainData.chunkArray.length / terrainData.numChunksD_1;\n\t}\n\n\tthis.loadPagedImageCallback = function(callback, infaltedBuffer){\n\t\tvar self = this;\n\n\t\t// Prep output array\n\t\tself.getOutput().terrainTiles = [];\n\n\t\tvar pimgDS = new DataStream(infaltedBuffer);\n\t\tvar pimgFile = new GW2File(pimgDS,0);\n\t\tvar pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n\t\tvar pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n\t\tthis.mapRect = null;\n\n\t\t/// Fetch chunks\n\t\tvar terrainData = this.mapFile.getChunk(\"trn\").data;\n\t\tvar parameterData = this.mapFile.getChunk(\"parm\").data;\n\n\t\t/// Read settings\n\t\tvar maxAnisotropy = this.settings.anisotropy ? this.settings.anisotropy : 1;\n\n\t\tvar chunks = [];\t\n\t\tvar chunkW = 35;\n\n\t\t/// Calculate numChunksD_1 and _2\n\t\tthis.parseNumChunks(terrainData);\n\n\t\tvar xChunks = terrainData.numChunksD_1;\n\t\tvar yChunks = terrainData.numChunksD_2;\n\n\t\tvar allMaterials = terrainData.materials.materials;\n\t\tvar allTextures = terrainData.materials.texFileArray;\n\n\t\t//Total map dx and dy\n\t\t/*\n\t\told parameter data definition:\n\t\t\"x1\", \"float32\",\n\t\t\"y1\", \"float32\",\n\t\t\"x2\", \"float32\",\n\t\t\"y2\", \"float32\"\n\t\t*/\n\t\t//var dx = parameterData.rect.x2 - parameterData.rect.x1;\n\t\t//var dy = parameterData.rect.y2 - parameterData.rect.y1;\n\t\tvar dx = parameterData.rect[2] - parameterData.rect[0];\n\t\tvar dy = parameterData.rect[3] - parameterData.rect[1];\n\n\t\t//Each chunk dx and dy\n\t\tvar cdx = dx/terrainData.numChunksD_1 * 1;//  35/33;\n\t\tvar cdy =dy/terrainData.numChunksD_2 * 1;//35/33;\n\t\tvar n=0;\n\t\tvar allMats = [];\n\t\tvar customMaterial = new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color:0x666666, flatShading: true}); \n\t\tvar texMats = {};\n\n\t\t/// Load textures from PIMG and inject as material maps (textures)\n\t\tvar chunkTextures={};\n\t\t\n\t\t/// Load textures\n\t\tif(pimgData){\n\t\t\tvar strippedPages = pimgData.strippedPages;\n\n\t\t\t///Only use layer 0\n\t\t\tstrippedPages.forEach(function(page){\n\t\t\t\t\n\t\t\t\t/// Only load layer 0 and 1\n\t\t\t\tif(page.layer<=1){\n\t\t\t\t\tvar filename = page.filename;\n\t\t\t\t\tvar color = page.solidColor;\n\t\t\t\t\tvar coord = page.coord;\n\n\t\t\t\t\tvar matName = coord[0]+\",\"+coord[1];\n\t\t\t\t\tif(page.layer == 1)\n\t\t\t\t\t\tmatName+=\"-2\";\n\n\n\t\t\t\t\t/// Add texture to list, note that coord name is used, not actual file name\n\t\t\t\t\tif(!chunkTextures[matName]){\n\n\t\t\t\t\t\t/// Load local texture, here we use file name!\n\t\t\t\t\t\tvar chunkTex = RenderUtils.loadLocalTexture(self.localReader, filename);\n\n\t\t\t\t\t\tif(chunkTex){\n\t\t\t\t\t\t\t/// Set repeat, antistropy and repeat Y\n\t\t\t\t\t\t\tchunkTex.anisotropy = maxAnisotropy;\n\t\t\t\t\t\t\tchunkTex.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tchunkTex.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t///...But store in coord name\n\t\t\t\t\t\tchunkTextures[matName] = chunkTex;\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});/// end for each stripped page in pimgData\n\t\t}\n\t\t\n\t\t\n\t\t\t\t\n\t\t/// Render Each chunk\n\t\t/// We'll make this async in order for the screen to be able to update\n\n\t\tvar renderChunk = function(cx,cy){\n\t\t\tvar chunkIndex = cy*xChunks + cx;\n\n\t\t\tvar pageX = Math.floor(cx/4);\n\t\t\tvar pageY = Math.floor(cy/4);\n\n\t\t\t//TODO: Terrain texture LOD ?\n\t\t\tvar chunkTextureIndices = allMaterials[chunkIndex].loResMaterial.texIndexArray;\n\t\t\tvar matFileName = allMaterials[chunkIndex].loResMaterial.materialFile;\t\t\n\t\t\t//var chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n\t\t\t//var matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n\n\n\t\t\tvar chunkData = terrainData.chunkArray[chunkIndex];\n\n\t\t\tvar mainTex = allTextures[chunkTextureIndices[0]];\n\t\t\tvar mat = customMaterial;\n\n\t\t\t/// TODO: just tick invert y = false...?\n\t\t\tvar pageOffetX = (cx % 4)/4.0;\n\t\t\tvar pageOffetY = 0.75 - (cy % 4)/4.0;\n\n\t\t\t//offset 0 -> 0.75\n\t\t\t\n\t\t\t\n\t\t\t//Make sure we have shared textures\n\n\t\t\t/// Load and store all tiled textures\n\t\t\tvar fileNames = [];\n\t\t\tfor(var gi=0;gi<chunkTextureIndices.length/2;gi++){\n\t\t\t\tvar textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n\t\t\t\tfileNames.push(textureFileName);\n\t\t\t\t\n\t\t\t\t/// If the texture is not already loaded, read it from the .dat!\n\t\t\t\tif(!chunkTextures[textureFileName]){\n\n\t\t\t\t\t/// Load local texture\n\t\t\t\t\tvar chunkTex = RenderUtils.loadLocalTexture(self.localReader, textureFileName);\n\n\t\t\t\t\tif(chunkTex){\n\t\t\t\t\t\t/// Set repeat, antistropy and repeat Y\n\t\t\t\t\t\tchunkTex.anisotropy = maxAnisotropy;\n\t\t\t\t\t\tchunkTex.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tchunkTex.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t}\n\n\t\t\t\t\tchunkTextures[textureFileName] = chunkTex;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}/// End for each chunkTextureIndices\n\n\t\t\t/// Create Composite texture material, refering the shared textures\n\t\t\tvar pageTexName=  pageX+\",\"+pageY;\t\t\t\t\n\t\t\tvar pageTexName2=  pageX+\",\"+pageY+\"-2\";\t\t\t\t\n\n\n\t\t\t/// TODO USe mapData (Chunk: env -> haze)\n\t\t\t//var fog = SceneUtils.getScene().fog;\n\t\t\tvar fog = {\n\t\t\t\tcolor: {r:1,g:1,b:1},\n\t\t\t\tnear: 0,\n\t\t\t\tfar: 0\n\t\t\t}\n\n\t\t\t/// Get haze color from environment rednerer\n\t\t\tvar envOutput = self.getOutput(T3D.EnvironmentRenderer);\n\t\t\tif(envOutput.hazeColor){\n\t\t\t\tfog.color.r  = envOutput.hazeColor[2]/255.0;\n\t\t\t\tfog.color.g  = envOutput.hazeColor[1]/255.0;\n\t\t\t\tfog.color.b  = envOutput.hazeColor[0]/255.0;\n\t\t\t}\n\t\t\t\n\t\t\tvar uniforms = THREE.UniformsUtils.merge([\n\t    \t\tTHREE.UniformsLib['lights'],\n\t\t\t]);\n\n\t\t\t/// TODO: READ FROM VO, don't default to hard coded scale\n\t\t\tuniforms.uvScale = { type: \"v2\", value: new THREE.Vector2( 8.0, 8.0 ) };\n\t\t\tuniforms.offset = { type: \"v2\", value: new THREE.Vector2( pageOffetX, pageOffetY) };\n\n\t\t\tuniforms.texturePicker = {type: \"t\", value: chunkTextures[pageTexName]};\n\t\t\tuniforms.texturePicker2 = {type: \"t\", value: chunkTextures[pageTexName2]};\n\n\t\t\tuniforms.texture1 = { type: \"t\", value: chunkTextures[fileNames[0]]};\n\t\t\tuniforms.texture2 = { type: \"t\", value: chunkTextures[fileNames[1]]};\n\t\t\tuniforms.texture3 = { type: \"t\", value: chunkTextures[fileNames[2]]};\n\t\t\tuniforms.texture4 = { type: \"t\", value: chunkTextures[fileNames[3]]};\n\t\t\t\n\t\t\t\n\t\t\tmat = new THREE.ShaderMaterial( {\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tfragmentShader: TerrainShader.getFragmentShader(),\n\t\t\t\tvertexShader: TerrainShader.getVertexShader()\n\t\t\t} );\n\n\t\t\t///Store referenceto each material\n\t\t\tallMats.push(mat);\n\n\t\t\t\n\t\t\t/// -1 for faces -> vertices , -2 for ignoring outer faces\n\t\t\tvar chunkGeo =  new THREE.PlaneBufferGeometry ( cdx, cdy, chunkW-3, chunkW-3);\n\n\t\t\tvar cn = 0;\n\n\t\t\t///Render chunk\n\n\t\t\t/// Each chunk vertex\n\t\t\tfor(var y=0; y<chunkW; y++){\n\n\t\t\t\tfor(var x=0; x<chunkW; x++){\n\t\t\t\n\t\t\t\t\tif(  x != 0 && x !=chunkW-1 && y!=0 && y !=chunkW-1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tchunkGeo.getAttribute('position').array[cn*3+2] = terrainData.heightMapArray[n];\n\t\t\t\t\t\tcn++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tn++;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} // End each chunk vertex\n\n\t\t\t\n\t\t\t/// Flip the plane to fit wonky THREE js world axes\n\t\t\tvar mS = (new THREE.Matrix4()).identity();\n\t\t\tmS.elements[5] = -1;\n\t\t\tchunkGeo.applyMatrix(mS);\n\n\t\t\t/// Compute face normals for lighting, not used when textured\n\t\t\tchunkGeo.computeFaceNormals();\n\t\t\t//chunkGeo.computeVertexNormals();\n\n\n\t\t\t/// Build chunk mesh!\n\t\t\tvar chunk;\n\t\t\tchunk = new THREE.Mesh(\tchunkGeo , customMaterial );\n\t\t\tif(mat.length){\n\t\t\t\tchunk = THREE.SceneUtils.createMultiMaterialObject( chunkGeo, mat );\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchunk = new THREE.Mesh(\tchunkGeo , mat );\t\n\t\t\t}\t\n\n\n\t\t\t///Move and rotate Mesh to fit in place\n\t\t\tchunk.rotation.set(Math.PI/2,0,0);\n\t\t\t\n\t\t\t/// Last term is the new one: -cdx*(2/35)\n\t\t\tvar globalOffsetX = parameterData.rect[0] + cdx/2;\n\t\t\tvar chunkOffsetX = cx * cdx;\n\n\t\t\tchunk.position.x = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(terrainData.numChunksD_2 % 2 == 0){\n\t\t\t\t\n\t\t\t\t/// Last term is the new one: -cdx*(2/35)\n\t\t\t\tvar globalOffsetY = parameterData.rect[1] + cdy/2 -0;// -cdy*(1/35);\n\t\t\t\tvar chunkOffsetY = cy * cdy * 1;//33/35;\n\n\t\t\t\tchunk.position.z =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  parameterData.rect[1] - cdy/2 + 0; //cdy*(1/35);\n\t\t\t\tvar chunkOffsetY = cy * cdy * 1;//33/35;\n\n\t\t\t\tchunk.position.z = globalOffsetY +  chunkOffsetY;\t\n\t\t\t}\n\n\n\t\t\tvar px = chunk.position.x;\n\t\t\tvar py = chunk.position.z;\n\n\n\t\t\tif(!self.mapRect){\n\t\t\t\tself.mapRect = {\n\t\t\t\t\tx1:px-cdx/2, x2:px+cdx/2,\n\t\t\t\t\ty1:py-cdy/2, y2:py+cdy/2 };\n\t\t\t}\n\t\t\t\n\t\t\tself.mapRect.x1 = Math.min(self.mapRect.x1, px -cdx/2);\n\t\t\tself.mapRect.x2 = Math.max(self.mapRect.x2, px +cdx/2);\n\n\t\t\tself.mapRect.y1 = Math.min(self.mapRect.y1, py -cdy/2);\n\t\t\tself.mapRect.y2 = Math.max(self.mapRect.y2, py +cdy/2);\n\t\t\t\n\t\t\tchunk.updateMatrix();\n\t\t\tchunk.updateMatrixWorld ();\n\n\t\t\t/// Add to list of stuff to render\n\t\t\t/// TODO: Perhaps use some kind of props for each entry instead?\n\t\t\tself.getOutput().terrainTiles.push( chunk );\t\t\n\n\t\t} /// End render chunk function\n\n\n\t\tvar stepChunk = function(cx,cy){\n\t\t\tif(cx>=xChunks){\n\t\t\t\tcx = 0;\n\t\t\t\tcy++;\n\t\t\t}\n\n\t\t\tif(cy>=yChunks){\n\n\t\t\t\t/// Draw water surface using map bounds\t\t\t\t\n\t\t\t\tself.getOutput().water = self.drawWater(self.mapRect);\n\n\t\t\t\t/// Set bounds in output VO\n\t\t\t\tself.getOutput().bounds = self.mapRect;\n\n\t\t\t\t/// Fire call back, we're done rendering.\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pct =  Math.floor( 100*(cy * xChunks + cx) /( xChunks * yChunks ) );\n\n\t\t\tself.logger.log(T3D.Logger.TYPE_PROGRESS,\"Loading Terrain\", pct);\n\n\t\t\trenderChunk(cx,cy);\n\t\t\tsetTimeout(stepChunk,1,cx+1,cy);\n\t\t}\n\n\t\tstepChunk(0,0);\n\t};\n}\n\n\n/// DataRenderer inheritance:\nTerrainRenderer.prototype = Object.create(DataRenderer.prototype);\nTerrainRenderer.prototype.constructor = TerrainRenderer;\n\n/**\n * Output fileds generated:\n * \n * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n * \n * - *water* A THREE.Mesh object visualizing the bounds of the map.\n * \n * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nTerrainRenderer.prototype.renderAsync = function(callback){\n\t\n\t/// Load all paged Images, requires inflation of other pack files!\n\tvar pagedImageId =  this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n\tthis.localReader.loadFile(pagedImageId, this.loadPagedImageCallback.bind(this, callback));\n}\n\n/**\n * TODO: write description. Used for export feature\n * \n * @param  {Function} callback [description]\n * @return {*}            [description]\n */\nTerrainRenderer.prototype.getFileIdsAsync = function(callback){\n\n\tvar terrainChunk = this.mapFile.getChunk(\"trn\");\n\tvar pimgTableDataChunk = this.mapFile.getChunk(\"pimg\");\n\tvar fileIds = [];\n\n\t/// ------------ SPLASH TEXTURES ------------\n\tvar pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\tvar strippedPages = pimgData.strippedPages;\n\t\n\t///Only use layer 0\n\tstrippedPages.forEach(function(page){\n\t\t\t\n\t\t/// Only load layer 0 and 1\n\t\tif(page.layer<=1 && page.filename>0){\n\t\t\tfileIds.push( page.filename );\n\t\t}\n\t});\n\t/// ------------ END SPLASH TEXTURES ------------\n\n\n\n\t/// ------------ TILED IMAGES ------------\n\tvar terrainData = terrainChunk.data;\n\tvar allTextures = terrainData.materials.texFileArray;\n\tallTextures.forEach(function(texture){\n\t\tif(texture.filename>0)\n\t\t\tfileIds.push(texture.filename);\n\t})\n\t/// ------------ END TILED IMAGES ------------\n\n\n\n\treturn fileIds;\n};\n\nmodule.exports = TerrainRenderer;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"../util/RenderUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates zone models for a map.\n * \n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction ZoneRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\tthis.mapFile = this.settings.mapFile;\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} zone               [description]\n\t * @param  {*} zoneDefs           [description]\n\t * @param  {*} mapRect            [description]\n\t * @param  {*} renderZoneCallback [description]\n\t * @return {*}                    [description]\n\t */\n\tthis.renderZone = function(zone, zoneDefs, mapRect, renderZoneCallback){\n\t\tvar self = this;\n\n\t\t/// Get Zone Definition\n\t\tvar zoneDef = null;\n\t\tzoneDefs.forEach(function(zd){\n\t\t\tif(!zoneDef && zd.token == zone.defToken)\n\t\t\t\tzoneDef = zd;\n\t\t});\n\n\t\t/// Create array of all models to add:\n\t\tvar models = [];\n\t\tvar modelGroups = this.getModelGroups(zone, zoneDef, mapRect);\n\n\t\t/// Create empty mesh cache\n\t\tself.meshCache = {};\n\t\tself.textureCache = {};\n\n\t\t/*\n\t\t * ---Keeping this out of the doc for now---\n\t\t * Steps trough each model and renders it to the scene, allowing for efficient caching.\n\t\t * @param  {Number} i - Current index within the models array\n\t\t */\n\t\t//var lastPct = -1;\n\t\tvar groupKeys = Object.keys(modelGroups);\n\t\tfunction stepModels(i){\n\n\t\t\t/*var pct = Math.round(100.0*i / groupKeys.length);\n\t\t\tif(lastPct!=pct){\n\t\t\t\tconsole.log(\"Rendering ZONE models \"+pct);\n\t\t\t\tlastPct = pct;\n\t\t\t}*/\n\n\t\t\tif(i>=groupKeys.length){\n\n\t\t\t\t/// Empty mesh cache\n\t\t\t\tself.meshCache = {};\n\t\t\t\tself.textureCache = {};\n\n\t\t\t\t/// Tell caller this zone is done loading\n\t\t\t\trenderZoneCallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/// Read model at index\n\t\t\t/// var model = models[i];\n\t\t\tvar key = groupKeys[i]; /// key is model filename\n\t\t\tvar group = modelGroups[key];\n\n\t\t\tvar meshGroups = [];\n\t\t\t\n\t\t\t/// Get model just once for this group\n\t\t\tvar showUnmaterialed = false;\n\t\t\tRenderUtils.getMeshesForFilename(key, null, self.localReader, self.meshCache, self.textureCache, showUnmaterialed,\n\n\t\t\t\tfunction(meshes, isCached){\n\t\t\t\t\t\n\t\t\t\t\t/// If there were meshes, add them to the scene with correct scaling rotation etc.\n\t\t\t\t\tif(meshes /* && meshes.length == 3*/){\n\n\t\t\t\t\t\t/// Add one copy per model instance\n\t\t\t\t\t\t/// TODO: add rotation!\n\t\t\t\t\t\t/// TODO: fine tune position?\n\t\t\t\t\t\t/// TODO: POTIMIZE!\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tgroup.forEach(function(model, instanceIdx){\n\n\t\t\t\t\t\t\tvar isCached = true;\n\t\t\t\t\t\t\tvar scale = 1.0;\n\n\t\t\t\t\t\t\t/// For each Mesh in the model\n\t\t\t\t\t\t\tmeshes.forEach(function(mesh, meshIdx){\n\n\t\t\t\t\t\t\t\tif(mesh.materialFlags == 525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521*/ ){\n\t\t\t\t\t\t\t\t\t//console.log(\"Skipping lod\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tvar move = {x:0,y:0,z:0};\n\n\t\t\t\t\t\t\t \t/// Add to big mesh\n\t\t\t\t\t\t\t \tif(!meshGroups[meshIdx]){\n\t\t\t\t\t\t\t \t\tvar mg = mesh.geometry.clone();\n\t\t\t\t\t\t\t \t\tmeshGroups[meshIdx] = {\n\t\t\t\t\t\t\t \t\t\treadVerts : mg.getAttribute('position').array,\n\t\t\t\t\t\t\t \t\t\tverts: new Float32Array( group.length * mg.getAttribute('position').array.length ),\n\n\t\t\t\t\t\t\t \t\t\treadIndices : mg.getIndex().array,\n\t\t\t\t\t\t\t \t\t\tindices: new Uint32Array( group.length * mg.getIndex().array.length ),\n\n\t\t\t\t\t\t\t \t\t\treadUVs : mg.getAttribute('uv').array,\n\t\t\t\t\t\t\t \t\t\tuvs: new Float32Array( group.length * mg.getAttribute('uv').array.length ),\n\n\t\t\t\t\t\t\t \t\t\treadNormals : mg.getAttribute('normal').array,\n\t\t\t\t\t\t\t \t\t\tnormals: new Float32Array( group.length * mg.getAttribute('normal').array.length ),\n\n\t\t\t\t\t\t\t \t\t\tmaterial:mesh.material,\n\t\t\t\t\t\t\t \t\t\t//material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n\t\t\t\t\t\t\t \t\t\t/*material : new THREE.PointCloudMaterial ({\n\t\t\t\t\t\t\t\t\t      color: 0xFF0000,\n\t\t\t\t\t\t\t\t\t      size: 20\n\t\t\t\t\t\t\t\t\t    }),*/\n\t\t\t\t\t\t\t \t\t\tposition:{x:model.x, y:model.y, z:model.z}\n\t\t\t\t\t\t\t \t\t}\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t\t \telse{\n\t\t\t\t\t\t\t \t\t/// Translate\n\t\t\t\t\t\t \t\t\tmove.x = model.x - meshGroups[meshIdx].position.x;\n\t\t\t\t\t\t \t\t\tmove.y = model.z - meshGroups[meshIdx].position.z;\n\t\t\t\t\t\t \t\t\tmove.z = model.y - meshGroups[meshIdx].position.y;\n\t\t\t\t\t\t\t \t}\n\n\t\t\t\t\t\t\t \t/// Add geom verts\n\t\t\t\t\t\t\t \tvar readVerts = meshGroups[meshIdx].readVerts;\n\t\t\t\t\t\t\t \tvar writeVerts = meshGroups[meshIdx].verts;\n\t\t\t\t\t\t\t \tvar stride = readVerts.length;\n\n\t\t\t\t\t\t\t \tfor ( var i = 0, j = instanceIdx * stride; i < stride; i +=3, j +=3 ) {\n\t\t\t\t\t\t\t\t\twriteVerts[ j + 0 ] = readVerts[ i + 0 ] + move.x;\n\t\t\t\t\t\t\t\t\twriteVerts[ j + 1 ] = readVerts[ i + 1 ] + move.y;\n\t\t\t\t\t\t\t\t\twriteVerts[ j + 2 ] = readVerts[ i + 2 ] + move.z;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar readIndices = meshGroups[meshIdx].readIndices;\n\t\t\t\t\t\t\t \tvar writeIndices = meshGroups[meshIdx].indices;\n\t\t\t\t\t\t\t \tvar strideIndices = readIndices.length;\n\t\t\t\t\t\t\t \tvar shift = stride * instanceIdx  / 3;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, j = instanceIdx * strideIndices; i < strideIndices; i ++, j ++ ) {\n\t\t\t\t\t\t\t\t\twriteIndices[ j ] = readIndices[ i ] + shift;\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\tvar readUVs = meshGroups[meshIdx].readUVs;\n\t\t\t\t\t\t\t\tvar writeUvs = meshGroups[meshIdx].uvs;\n\t\t\t\t\t\t\t\tvar uvStride = readUVs.length;\n\t\t\t\t\t\t\t\tfor ( var i = 0, j = instanceIdx * uvStride; i < uvStride; i ++, j ++ ) {\n\t\t\t\t\t\t\t\t\twriteUvs[ j ] = readUVs[ i ];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar readNormals = meshGroups[meshIdx].readNormals;\n\t\t\t\t\t\t\t\tvar writeNormals = meshGroups[meshIdx].normals;\n\t\t\t\t\t\t\t\tvar normalStride = readNormals.length;\n\t\t\t\t\t\t\t\tfor ( var i = 0, j = instanceIdx * normalStride; i < normalStride; i ++, j ++ ) {\n\t\t\t\t\t\t\t\t\twriteNormals[ j ] = readNormals[ i ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t});// End for each model in group\n\t\t\t\t\t\t\n\t\t\t\t\t}/// End if meshes\n\n\t\t\t\t\t/// Add each cluster of merged meshes to scene\n\t\t\t\t\tmeshGroups.forEach(function(meshGroup){\n\n\t\t\t\t\t\tvar mergedGeom = new THREE.BufferGeometry();\n\t\t\t\t\t\t\n\t\t\t\t\t\tmergedGeom.addAttribute( 'position', new THREE.BufferAttribute( meshGroup.verts, 3 ) );\n\t\t\t\t\t\t//mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n\t\t\t\t\t\tmergedGeom.setIndex(new THREE.BufferAttribute(meshGroup.indices, 1));\n\t\t\t\t\t\tmergedGeom.addAttribute( 'normal', new THREE.BufferAttribute( meshGroup.normals, 3 ) );\n\t\t\t\t\t\tmergedGeom.addAttribute( 'uv', new THREE.BufferAttribute( meshGroup.uvs, 2) );\n\n\t\t\t\t\t\tmergedGeom.buffersNeedUpdate = true;\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( mergedGeom, meshGroup.material );\n\t\t\t\t\t\tmesh.position.set(meshGroup.position.x, meshGroup.position.z, meshGroup.position.y);\n\n\t\t\t\t\t\tself.getOutput().meshes.push(mesh);\n\n\t\t\t\t\t});// End for each meshgroup\n\n\n\t\t\t\t\t/// Rendering is done, render next.\n\t\t\t\t\tstepModels(i+1);\n\t\t\t\t}\n\n\t\t\t);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}/// End function stepModels\n\n\t\t/// Begin stepping trough the models, rendering them.\n\t\tstepModels(0);\n\t}\n\n\n\t/**\n\t * TODO\n\t * \n\t * @param  {*} zone    [description]\n\t * @param  {*} zoneDef [description]\n\t * @param  {*} mapRect [description]\n\t * @return {*}         [description]\n\t */\n\tthis.getModelGroups = function(zone, zoneDef, mapRect){\n\n\t\t/// Calculate rect in global coordinates\n\t\tvar zPos = zone.zPos;\n\n\t\tvar mapX = mapRect[0];\n\t\tvar mapY = mapRect[1];\n\t\tvar c  = 32+16;\n\n\t\t// [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n\t\tvar zoneRect = {\n\t\t\tx1:zone.vertRect[0]*c+mapX,\n\t\t\tx2:zone.vertRect[2]*c+mapX,\n\t\t\ty1:zone.vertRect[1]*-c-mapY,\n\t\t\ty2:zone.vertRect[3]*-c-mapY\n\t\t};\t\n\n\t\t\n\n\t\t/// Zone width and depth in local corrdinates\n\t\t/*var zdx = zone.vertRect.x1-zone.vertRect.x2;\n\t\tvar zdy = zone.vertRect.y1-zone.vertRect.y2;*/\n\t\t\n\t\t/// These zones seems to overflow :/\n\t\tif(zone.encodeData.length == 0){\n\t\t\treturn {};\n\t\t}\n\t\t\n\t\t//console.log(\"Get mdl groups\", zone);\n\t\t/// Testing: Render Zone Vert Rect\n\t\t//RenderUtils.renderRect(zoneRect, -zPos);\n\n\t\tvar zdx = zone.vertRect[0]-zone.vertRect[2];\n\t\tvar zdy = zone.vertRect[1]-zone.vertRect[3];\n\n\t\t/// Zone Flags increases a linear position, used to step trough the Zone.\n\t\tvar linearPos = 0;\n\n\t\tvar modelGroups = {};\n\n\t\tvar terrainTiles = this.getOutput(T3D.TerrainRenderer).terrainTiles;\n\n\t\tfor(var i = 0; i< zone.flags.length; i+=2){\n\n\t\t\t/// Step forward\n\t\t\tlinearPos += zone.flags[i];\n\n\t\t\t/// Check if a model should be placed\n\t\t\tvar flag = zone.flags[i+1];\n\t\t\tif(flag!=0){\n\t\t\t\t\n\t\t\t\t/// Extract flag data\n\t\t\t\t/// Layer is written in the last 4 bytes\n\t\t\t\tvar zoneDefLayer = flag >> 4;\n\n\t\t\t\t/// Get Zone Definition Layer\n\t\t\t\tvar layer = zoneDef.layerDefArray[zoneDefLayer-1];\n\n\t\t\t\t/// TESTING Only show layers with height >= 3\n\t\t\t\tif(layer/* && layer.height >= 0*/){\n\n\t\t\t\t\t/// Get X and Y from linear position\n\t\t\t\t\tvar modelX = (linearPos % zdx)*c + zoneRect.x1;\n\t\t\t\t\tvar modelY = Math.floor(linearPos / zdx)*c + zoneRect.y1;\n\n\t\t\t\t\t/// Get Z from intersection with terrain\n\t\t\t\t\tvar modelZ = null;\n\n\t\t\t\t\tvar startZ = 100000;\n\n\t\t\t\t\tvar raycaster = new THREE.Raycaster(\n\t\t\t\t\t\tnew THREE.Vector3(modelX, startZ, modelY),\n\t\t\t\t\t\tnew THREE.Vector3(0, -1, 0)\n\t\t\t\t\t);\n\n\t\t\t\t\t/// TODO: OPT?\n\t\t\t\t\tterrainTiles.forEach(function(chunk){\n\t\t\t\t\t\tif(modelZ === null){\n\t\t\t\t\t\t\tvar intersections = raycaster.intersectObject(chunk);\n\t\t\t\t\t\t\tif(intersections.length>0){\n\t\t\t\t\t\t\t\tmodelZ = startZ - intersections[0].distance;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t/// Get model id\n\t\t\t\t\t/// TODO: check with modelIdx = flag & 0xf;\n\t\t\t\t\tvar modelIdx = 0; \n\t\t\t\t\tvar model = layer.modelArray[modelIdx];\n\t\t\t\t\tvar modelFilename = model.filename;\n\t\t\t\t\tvar zOffsets = model.zOffsets;\n\n\t\t\t\t\tvar layerFlags = layer.layerFlags; //NOrmaly 128, 128\n\t\t\t\t\t\n\t\t\t\t\t//TODO: flip z,y?\n\t\t\t\t\tvar rotRangeX = layer.rotRangeX;//max min\n\t\t\t\t\tvar rotRangeY = layer.rotRangeY;//max min\n\t\t\t\t\tvar rotRangeZ = layer.rotRangeZ;//max min\n\t\t\t\t\tvar scaleRange = layer.scaleRange;//max min\n\t\t\t\t\tvar fadeRange = layer.fadeRange;//max min\n\n\t\t\t\t\t//Unused\n\t\t\t\t\t//tiling: 3\n\t\t\t\t\t//type: 1\n\t\t\t\t\t//width: 2\n\t\t\t\t\t//radiusGround: 2\n\n\t\t\t\t\t/// Create modelGroup (this zone only)\n\t\t\t\t\tif(!modelGroups[modelFilename]){\n\t\t\t\t\t\tmodelGroups[modelFilename] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Add entry to model group\n\t\t\t\t\tmodelGroups[modelFilename].push({\n\t\t\t\t\t\tx:modelX,\n\t\t\t\t\t\ty:modelY,\n\t\t\t\t\t\tz:modelZ,\n\t\t\t\t\t\trotRangeX:rotRangeX,\n\t\t\t\t\t\trotRangeY:rotRangeY,\n\t\t\t\t\t\trotRangeZ:rotRangeZ,\n\t\t\t\t\t\tscaleRange:scaleRange,\n\t\t\t\t\t\tfadeRange:fadeRange\n\n\t\t\t\t\t});\n\t\t\t\t\t\n\n\t\t\t\t}/// End if layer\n\n\t\t\t\t\n\t\t\t}/// End if flag != 0\n\n\t\t} /// End for each flag\n\n\t\treturn modelGroups;\n\t}\n}\n\n/// NOT USED??\nfunction addZoneMeshesToScene(meshes, isCached, position, scale, rotation){\n\t\n\t/// Called for each mesh in the zone\n\t/// TODO: Opt opt opt...\n\n    meshes.forEach(function(mesh){\n\n    \t/// Create new mesh if we got back a cached original.\n\t\tif(isCached)\n\t\t\tmesh = new THREE.Mesh( mesh.geometry, mesh.material );\n\n    \t/// Scale, position and rotate.\n    \tmesh.scale.set( scale, scale, scale );\n    \tif(rotation){\n\t    \tmesh.rotation.order = \"ZXY\";\n\t    \tmesh.rotation.set(rotation.x, rotation.y, rotation.z);\n\t    }\n    \tmesh.position.set(position.x, position.y, position.z);\n\n    \t/// Add to export\n    \tthis.getOutput().meshes.push(mesh);\n\t});\n\n}\n\n\n/// DataRenderer inheritance:\nZoneRenderer.prototype = Object.create(DataRenderer.prototype);\nZoneRenderer.prototype.constructor = ZoneRenderer;\n\n/**\n * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n * \n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nZoneRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t/// Set up output array\n\tself.getOutput().meshes = [];\n\t\n\tvar zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n\tvar parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\tvar terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n\tvar mapRect = parameterChunkData.rect;\n\t\t\t\t\n\t/// Zone data\n\tvar zones = zoneChunkData.zoneArray;\n\tvar zoneDefs = zoneChunkData.zoneDefArray;\n\n\t/// Render each zone\n\tlastPct = -1;\t\t\n\n\t/// Main render loop, render each zone\n\tfunction stepZone(i){\n\n\t\tvar pct = Math.round(100.0*i / zones.length);\n\t\tif(lastPct!=pct){\n\t\t\tself.logger.log(\n\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\"Loading 3D Models (Zone)\", pct\n\t\t\t);\n\t\t\tlastPct = pct;\n\t\t}\n\n\t\tif(i >= zones.length){\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t\t/// Main zone render function call\n\t\tself.renderZone(zones[i], zoneDefs, mapRect,\n\t\t\tstepZone.bind(self,i+1)\n\t\t);\t\n\n\t}\n\n\tstepZone(0);\n}\n\nmodule.exports = ZoneRenderer;\n\n//// Not used: zone defintion per chunk data \"images\" 32*32 points\n/*\n//Total map dx and dy\nvar d = terrainChunkHeader.data;\nvar pd = parameterChunkHeader.data;\nvar dx = (pd.rect.x2-pd.rect.x1);\nvar dy = (pd.rect.y2-pd.rect.y1);\n\n//Each chunk dx and dy\n\nvar c =1;\nvar cdx = c*dx/d.dims.dim1;\n\nvar cdy = c*dy/d.dims.dim2;\n\nvar cdx = dx/(d.numChunksD_1*2);\nvar cdy =dy/(d.numChunksD_2*2);\n\n\nfor(var i=0; i<zoneDefs.length; i++){\n\tvar zoneDef = zoneDefs[i];\n\t\n\t//TODO: opt!\n\tzoneDef.layerDefs.forEach(function(layer){\n\n\t\tlayer.modelArray.forEach(function(model){\n\t\t\n\t\t\t\n\t\t});\n\t\t\n\n\t});\n\n\tvar chunkMat = new THREE.MeshBasicMaterial(\n\t\t{\n\t\t\tcolor: 0x00ff00,\n\t\t\twireframe:true,\n\t\t \topacity: 1.0,\n\t\t}\n\t);\n\n\t//TODO: opt!\n\t\n\tif(\n\t\tzoneDef.token == 597  ||\n\t\tzoneDef.token == 1369  ||\n\t\tzoneDef.token == 903  \n\t){\n\n\t\tzoneDef.pageTable.pageArray.forEach(function(page){\n\t\t\tvar flags = page.flags;\n\t\t\tvar coord = page.chunkCoord;\n\n\n\t\t\t//Hightlight this coord\n\t\t\tvar rect = {};\n\n\t\t\t\n\t\t\t//var globalOffsetX = pd.rect.x2 - cdx;\n\t\t\tvar globalOffsetX = pd.rect.x1 + cdx/2;\n\t\t\tvar chunkOffsetX = coord[0] * cdx;\n\n\t\t\trect.x1  = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(d.numChunksD_2 % 2 == 0){\n\t\t\t\t\n\t\t\t\tvar globalOffsetY = -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1  =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1 = globalOffsetY +  chunkOffsetY;\t\n\t\t\t}\n\n\t\t\trect.x2 = rect.x1+cdx;\n\t\t\trect.y2 = rect.y1+cdy;\n\n\n\t\t\t\n\n\t\t\tRenderUtils.renderRect(rect, 4000,chunkMat, 4000);\n\n\t\t\t//for(var j=0; j<flags.length; j++){\n\t\t\t//\tif(flags[j]>0){\n\t\t\t//\t\tconsole.log(\"Found flag\",flags[j],\"@ zoneDef\",zoneDef.token,\"coord\",coord,\"index\",j);\n\t\t\t//\t}\n\t\t\t//}\n\t\t});\n\n\t}\n\n}*/","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst HEAD_STRUCT = [\n\t'type', 'cstring:4',\n\t'chunkDataSize', 'uint32',\n\t'chunkVersion', 'uint16',\n\t'chunkHeaderSize', 'uint16',\n\t'offsetTableOffset', 'uint32',\n];\n\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private \n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nvar DUPLICATE_SETTINGS;\n\n//Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\nconst PACKTOCHUNK = [\n\t{pack: 'MODL', chunk: 'ANIM', root: 'ModelFileAnimation'},\n\t{pack: 'MODL', chunk: 'GAME', root: 'ModelFileGame'},\n\t{pack: 'MODL', chunk: 'SKEL', root: 'ModelFileSkeleton'},\n\t{pack: 'MODL', chunk: 'TOOL', root: 'ModelFileTool'},\n\t{pack: 'cntc', chunk: 'Main', root: 'PackContent'},\n\t{pack: 'mMet', chunk: 'Main', root: 'PackMapMetadata'},\n\t{pack: 'AMAT', chunk: 'TOOL', root: 'AmatToolParams' },\n\t{pack: 'cmaC', chunk: 'main', root: 'CollideModelManifest' }\n];\n\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\nfunction genDuplicateSettings(){\n\t//Early return if the settings have been already generated\n\tif(DUPLICATE_SETTINGS)\n\t\treturn;\n\t\n\tfunction getRootName(definition){\n\t\tlet a = new definition();\n\t\treturn Object.keys(a).filter(v => { return a[v] === a.__root && v!= '__root'})[0];\n\t}\n\n\tDUPLICATE_SETTINGS = {};\n\tlet duplicate_settings = {};\n\tfor (let setting of PACKTOCHUNK){\n\n\t\tlet regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\n\t\tlet chunkDef = T3D.formats.filter(v => { return v.name == setting.chunk});\n\n\t\tfor(let defsIdx in chunkDef){\n\t\t\tlet defs = chunkDef[defsIdx].versions;\n\t\t\tlet lastVersion = defs[Object.keys(defs).pop()];\n\t\t\tlet rootName = getRootName(lastVersion);\n\t\t\tif(rootName.match(regex)){\n\t\t\t\tif(!DUPLICATE_SETTINGS[setting.chunk])\n\t\t\t\t\tDUPLICATE_SETTINGS[setting.chunk] = [];\n\t\t\t\tDUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nclass GW2Chunk {\n\n\tconstructor(ds, addr){\n\t\t//Early returns if already called, it defines the DUPLICATE_SETTINGS variable\n\t\tgenDuplicateSettings();\n\n\t\t/**\n\t\t * @property {DataStream} ds The DataStream data source used by this chunk.\n\t\t */\n\t\tthis.ds = ds;\n\n\t\t/**\n\t\t * @property {Number} addr The address to this Chunk within ds.\n\t\t */\n\t\tthis.addr = addr;\n\n\t\t/**\n\t\t * @property {Object} data The typed data read from the body of this chunk.\n\t\t */\n\t\tthis.data = null;\n\n\n\t\t/**\n\t\t * @property {Number} headerLength The length in bytes of the chunk header.\n\t\t */\n\t\tthis.headerLength  = NaN;\n\n\t\t/**\n\t\t * @property {Object} header Chunk header data.\n\t\t */\n\t\tthis.loadHead();\n\t}\n\n\t/**\n\t * Parses the chunk header data, populating the header property.\n\t */\n\tloadHead(){\n\t\tthis.ds.seek(this.addr);\t\n\t\tthis.header = this.ds.readStruct(HEAD_STRUCT);\n\n\t\tthis.headerLength = this.ds.position - this.addr;\n\t}\n\n\t/**\n\t * @param  {String} fileType The main type of the pack file containing this chunk.\n\t * Used for resolving chunk naming conflicts between pack file types.\n\t * @return {Array}\tDataStream formatted array describing the data\n\t * sctructures of this chunk\n\t */\n\tgetDefinition(fileType){\n\n\t\t/// Normally we're looking for the 0th occurance\n\t\t/// But some chunk names occur multiple times and we're interrested\n\t\t/// in the N:th occurance of the definition.\n\t\t/// \n\t\t/// I've no idea how this is automated, for now just use the \n\t\t/// settings object I've put together from experience.\n\t\tvar useNthIndex = 0;\n\n\t\t/// If this chunk has multiple definitions\n\t\t/// get to know what def to use...\n\t\tvar fileTypes = DUPLICATE_SETTINGS[this.header.type];\n\t\tif(fileTypes){\n\n\t\t\tuseNthIndex = -1;\n\n\t\t\t/// Check what file name entry matches this file name\n\t\t\tfor(var i=0; i<fileTypes.length && useNthIndex == -1; i++){\n\t\t\t\tvar ft = fileTypes[i];\n\n\n\t\t\t\tif(ft == fileType){\n\t\t\t\t\tuseNthIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// We didnt find this file name!\n\t\t\t/// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n\t\t\tif(useNthIndex == -1){\n\t\t\t\tdebugger;\n\t\t\t}\n\t\t}\n\n\t\tvar defsFound = 0;\n\t\tfor(var i=0; i<T3D.formats.length; i++){\n\t\t\tvar f = T3D.formats[i];\n\t\t\t\n\t\t\t/// Chunk name needs to match\n\t\t\tif(\tf.name == this.header.type ){\n\n\t\t\t\t/// There needs to be a chunk def version matching the one specifiend \n\t\t\t\t/// \n\t\t\t\t/// AND If this is the Nth occurance of the chunk definition\n\t\t\t\t/// and we're looking for the Nth occurance, return it.\n\t\t\t\t/// \n\t\t\t\t/// chunkVersion in the dat uses 0 indexing\n\t\t\t\tif( defsFound == useNthIndex && f.versions[this.header.chunkVersion] ){\n\t\t\t\t\treturn ( new f.versions[this.header.chunkVersion]() ).__root;\t\n\t\t\t\t}\n\n\t\t\t\tdefsFound++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parses the chunk main data, populating the data property.\n\t * \n\t * @param  {String} fileType The main type of the pack file containing this chunk.\n\t * Used for resolving chunk naming conflicts between pack file types when\n\t * looking up the structure definition for this chunk.\n\t */\n\tloadData(fileType){\n\n\t\tvar def = this.getDefinition(fileType);\n\t\t\n\t\tif(def){\n\t\t\tthis.ds.seek(this.addr + this.headerLength);\n\t\t\tthis.data =  this.ds.readStruct(def);\n\t\t}\n\n\t\telse{\n\t\t\tT3D.Logger.log(T3D.Logger.TYPE_WARNING,\n\t\t\t\t\"Could not find a definition for chunk\",\n\t\t\t\tthis.header.type,\n\t\t\t\t\"version\", this.header.chunkVersion,\n\t\t\t\t\"file name\", fileType);\n\t\t}\n\t\t\n\t}\n\n\t/**\n\t * Retrieves the next chunk is the datastream. In practice this means the next chunk\n\t * within the same pack file.\n\t * \n\t * @return {GW2Chunk} The next chunk if any, otherwise null.\n\t */\n\tnext(){\n\t\ttry{\n\t\t\t\n\t\t\t// Calculate actual data size, as mChunkDataSize\n\t\t\t// does not count the size of some header variables\n\t\t\treturn new GW2Chunk(this.ds,this.addr + 8 + this.header.chunkDataSize);\n\t\t}\n\t\tcatch(e){\n\t\t\t/// Out of bounds probably\t\t\n\t\t}\n\t\treturn null;\n\t}\n}\n\nmodule.exports = GW2Chunk;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Chunk = require('./GW2Chunk');\n\nconst HEAD_STRUCT = [\n\t'identifier', 'cstring:2',\n\t'unknownField1', 'uint16',\n\t'unknownField2', 'uint16',\n\t'pkFileVersion', 'uint16',\n\t'type', 'cstring:4'\n];\n\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nclass GW2File{\n\n\tconstructor(ds, addr, noChunks){\n\n\t\t/**\n\t\t * @property {DataStream} ds The DataStream data source used by this file.\n\t\t */\n\t\tthis.ds = ds;\n\n\t\t/**\n\t\t * @property {Number} addr The address to this File within ds.\n\t\t */\n\t\tthis.addr = addr;\n\n\t\t/// Not used anymore I think\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * @property {Number} headerLength The length in bytes of the file header.\n\t\t */\n\t\tthis.headerLength  = NaN;\n\n\t\t/**\n\t\t * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n\t\t *\n\t\t * @property chunks\n\t\t * @type GW2Chunk[]\n\t\t */\n\t\tthis.chunks = [];\n\t\t\n\n\t\t/**\n\t\t * @property {Object} header Chunk header data.\n\t\t */\n\t\tthis.readHead();\n\t\t\n\t\tif(!noChunks){\n\t\t\tthis.readChunks();\n\t\t}\n\t}\n\n\n\t/**\n\t * Parses the file header data, populating the header property.\n\t */\n\treadHead(){\n\t\tthis.ds.seek(this.addr);\n\t\tthis.header = this.ds.readStruct(HEAD_STRUCT);\n\t\tthis.headerLength = this.ds.position - this.addr;\n\t}\n\n\t/**\n\t * Parses the file headers and populates the chunks property.\n\t */\n\treadChunks(){\n\n\t\t/// Reset chunks\n\t\tthis.chunks = [];\n\n\t\t//var structs = this.getChunkStructs && this.getChunkStructs();\n\n\t\t/// Load basic Chunk in order to read the chunk header.\n\t\tvar ch = new Chunk(this.ds, this.headerLength + this.addr);\t\n\n\t\t//while(structs && ch!=null && ch.header.type){\n\t\twhile(ch!=null && ch.header.type){\n\n\t\t\t/// Load data and pass file type if we need to determine what chunk entry to use\n\t\t\t/// (Some chunks in different files share the same chunk name)\n\t\t\tch.loadData(this.header.type);\n\t\t\tthis.chunks.push(ch);\n\n\t\t\t/// Load next basic Chunk in order to read the chunk header.\n\t\t\tch = ch.next();\n\t\t}\n\t}\n\n\n\t/**\n\t * Get a GW2Chunk from this file\n\t * \n\t * @param  {String} type The name, or type of the desired chunk.\n\t * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n\t */\n\tgetChunk(type){\n\t\tfor(var i=0; i<this.chunks.length; i++){\n\t\t\tif( this.chunks[i].header.type.toLowerCase() == type.toLowerCase() )\n\t\t\t\treturn this.chunks[i]; \n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n\t * \n\t * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n\t */\n\tgetChunkStructs(){\n\t\treturn {}\n\t}\n\n}\n\nmodule.exports = GW2File;","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @namespace MaterialUtils\n */\n\n\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n * \n * @memberof MaterialUtils\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv){\n\n\tvar vdefs = \"\";\n\tvar adefs = \"\";\n\tvar reads = \"\";\n\tfor(var i=0; i< numUv; i++){\n\t\tvdefs += \"varying vec2 vUv_\"+(i+1)+\";\\n\";\n\t\t\n\t\t/// uv and uv2 are defined by THREE\n\t\tif(i>1)\n\t\t\tadefs += \"attribute vec2 uv\"+(i+1)+\";\\n\";\n\n\n\t\treads += \"vUv_\" + (i+1) + \" = uv\"+(i>0?(i+1):\"\")+\";\\n\";\n\t}\n\n\treturn adefs + vdefs +\n\t    \"void main()\\n\"+\n\t    \"{\\n\"+\n\t        reads+\n\t        \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\"+\n\t        \"gl_Position = projectionMatrix * mvPosition;\\n\"+\n\t    \"}\";\n}\n\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n * \n * @memberof MaterialUtils\n * @param {Number} width \n * @param {Number} height \n * @param {THREE.Color} color \n * @returns {THREE.DataTexture}\n */\nfunction generateDataTexture(width, height, color){\n\t// create a buffer with color data\n\tvar size = width * height;\n\tvar data = new Uint8Array( 4 * size );\n\tvar r = Math.floor( color.r * 255 );\n\tvar g = Math.floor( color.g * 255 );\n\tvar b = Math.floor( color.b * 255 );\n\tvar a = 255;\n\n\tfor ( var i = 0; i < size; i ++ ) {\n\t\tvar stride = i * 4;\n\n\t\tdata[ stride ] = r;\n\t\tdata[ stride + 1 ] = g;\n\t\tdata[ stride + 2 ] = b;\n\t\tdata[ stride + 3 ] = a;\n\t}\n\t// used the buffer to create a DataTexture\n\treturn new THREE.DataTexture( data, width, height, THREE.RGBAFormat );\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n * \n * @memberof MaterialUtils\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {any} lightMap  TODO\n * @returns {string}\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap){\n\tvar t1uv = \"vUv_\"+(textures[0].uvIdx+1);\n\t\n\n\tvar discard = \"\";\n\n\tif(alphaTest){\n\t\tdiscard = \"    if (c1.a < 0.5) \\n\"+\n    \t\"       discard;\\n\";\t\n\t}\n\n    /// Color from 1st text or lighted by 2nd?\n    var writeColor = \"gl_FragColor = c1;\\n\";\n\n    if(lightMap){\n    \tvar texIdx = 0;\n    \t//var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n    \tvar t2uv = \"vUv_1\";// + (textures[texIdx].uvIdx+1);\n    \t//console.log(\"t2uv\",t2uv);\n\n    \twriteColor = \"   vec4 c2 = texture2D( texture\"+(texIdx+1)+\", \"+t2uv+\" );\\n\"+\n\t    \"     gl_FragColor = c2;\\n\";\n\t    //\"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n    }\n\n\n    var uniforms = \"\"\n    textures.forEach(function(t,idx){\n    \tuniforms += \"uniform sampler2D texture\"+(idx+1)+\";\\n\";\n    });\n\t/*uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\";*/\n\n\tvar varyings = \"\";\t\n\tfor(var i=0; i< numUv; i++){\n\t\tvaryings += \"varying vec2 vUv_\"+(i+1)+\";\\n\";\n\n\t}\n\n\treturn uniforms + varyings +\n    \"void main( void ) {\\n\"+\n    \"    vec4 c1 = texture2D( texture1, \"+t1uv+\" );\\n\"+\n    discard +\n    writeColor +\n    \"}\";\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n * \n * @memberof MaterialUtils\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest){\n\n\tvar lightMap = false;\n\tvar uniforms = {};\n\n\ttextures.forEach(function(t,idx){\n\t\tuniforms[\"texture\"+idx] = { type: \"t\", value: t };\n\t});\n\n\tif(textures.length>1){\n\t\tlightMap = true;\t\t\n\t}\n\n\tvar attributes = {};\n\n\tfor(var i=2; i<numUV; i++){\n\t\tattributes[\"uv\"+(i+1)] =  { type: 'v2', value: [] };\n\t}\n\n\tvar vs = buildVS(numUV);\n\n\treturn new THREE.ShaderMaterial( {\n\t\tuniforms: uniforms,\n\t\tvertexShader: vs,\n\t\tfragmentShader: buildPS(\n\t\t\t\ttextures,\n\t\t\t\tnumUV,\n\t\t\t\talphaTest,\n\t\t\t\tlightMap\n\t\t\t), \n\t\tattributes: attributes,\n\t\tside: THREE.FrontSide,\n\t} );\n\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for \n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n * \n * @memberof MaterialUtils\n * @param  {ModelMaterialData} material \tA value object often automaticaly  \n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in \n *                                       \tAllFormats.js, look for the latest \n *                                       \tversion of ModelMaterialData\n *                                       \t\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.   \n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nfunction getMaterial(material, materialFile, localReader, sharedTextures){\n\n\tif(!materialFile)\n\t\treturn;\n\t\n\tvar dxChunk =  materialFile.getChunk(\"dx9s\");\n\tvar grChunk = materialFile.getChunk(\"grmt\");\n\n\t/// Append all textures to the custom material\n\tvar finalTextures = [];\n\t\n\t//Some materials don't use textures..\n\tif(material && material.textures.length/* && material.textures[texIndex]*/){\n\n\t\t/// TODO: check for flags!\t\t\t\n\t\t/// \n\t\t/// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n\t\t/// \n\t\t//console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n\t\t//if(grChunk.data.flags!=76)\n\t\t//\treturn;\n\n\t\t/// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n\t\t/// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n\t\t/// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n\t\t/// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\t\t\n\t\tvar effects = dxChunk.data.techniques[0].passes[0].effects;\n\t\t//var effect = effects[10];\n\t\tvar effect = effects[0];\n\n\t\tvar shader = dxChunk.data.shaders[effect.pixelShader];\n\t\t\n\t\t/*effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t});*/\n\t\t//var samplerIdx = effect.samplerIndex[0];\n\n\t\tvar samplerTextures = [];\n\t\tfor(var i=0; i<effect.samplerIndex.length; i++)\n\t\t{\n\n\t\t\tvar samplerIdx = effect.samplerIndex[i];\n\t\t\tvar sampler = dxChunk.data.samplers[samplerIdx];\n\n\t\t\t/// SHOULD NEVER HAPPEN, hide mesh!\n\t\t\tif(!sampler)\n\t\t\t\tcontinue;//return;\n\n\t\t\tvar textureToken = sampler && grChunk.data.texTokens[sampler.textureIndex];\n\t\t\tif(!textureToken)\n\t\t\t\ttextureToken = \"0-0\";\n\t\t\t/*else\n\t\t\t\ttextureToken =textureToken.val;*/\n\n\t\t\t/// Find the texture reffered by this sampler\n\t\t\tvar samplerTex = null;\n\n\t\t\tmaterial.textures.forEach(function(tex, index){\n\n\t\t\t\t///Seems like only 1st part of token is used...\n\t\t\t\tif(!samplerTex && tex.token.split(\"-\")[0] == textureToken.split(\"-\")[0]){\n\t\t\t\t\t//console.log(\"TEX match\",tex.token, textureToken)\n\t\t\t\t\tsamplerTex = tex;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/// Add this sampler's texture to the collection of all textures\n\t\t\tif(samplerTex){\n\t\t\t\tsamplerTextures.push(samplerTex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t///FALLBACK, just guess what texture we should use\n\t\t\t\tif(sampler)\n\t\t\t\t\tsamplerTextures.push(material.textures[sampler.textureIndex]);\n\t\t\t\telse if(material.textures.length>0)\n\t\t\t\t\tsamplerTextures.push(material.textures[0]);\n\t\t\t\telse return;\n\t\t\t}\n\n\n\t\t}/// END for each sampler index in effect\n\n\t\t/// We now have all textures\n\t\t//console.log(\"textures from sampler\", samplerTextures);\n\t\t\t\t\n\n\t\t/// Fallback to using whatever texture there is.\n\t\tif(samplerTextures.length <= 0){\n\t\t\treturn;\n\t\t\t//mainTex =  material.textures[0];\t\t\t\n\t\t}\n\n\n\t\t//console.log(\"num samplers \",samplerTextures.length);\n\t\tsamplerTextures.forEach(function(texture, idx){\n\n\t\t\tif(!texture)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t/// Set texture \"URL\"\n\t\t\tvar texURL = texture && texture.filename;\n\n\t\t\t/// Load texture from RAM or local reader:\n\t\t\tfinalTextures[idx] = getTexture(texURL, localReader, sharedTextures)\n\t\t\tif(finalTextures[idx]){\n\t\t\t\tfinalTextures[idx].uvIdx = texture.uvPSInputIndex;\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\n\t}/// End if material and texture\t\t\t\n\n\tvar finalMaterial;\n\n\n\t/// Create custom shader material if there are textures\n\tif(finalTextures){\n\n\t\t// TODO: make this work!\n\t\tif(false && finalTextures.length>0){\n\t\t\tfinalMaterial = getUVMat( finalTextures, material.texCoordCount, grChunk.data.flags!=16460 );\t\n\t\t}\n\t\telse{\n\t\t\tvar ft=false;\n\t\t\tvar nt=false;\n\t\t\tmaterial.textures.forEach(function(t){\n\t\t\t\t//Flag for diffuse map\n\t\t\t\tif(!ft && t.token.split(\"-\")[0] == \"1733499172\")\n\t\t\t\t\tft = t;\n\n\t\t\t\t//Flag for normal map\n\t\t\t\tif(!nt && t.token.split(\"-\")[0] == \"404146670\")\n\t\t\t\t\tnt = t;\n\t\t\t});\n\t\t\t\n\t\t\tif(!ft || ft.filename<=0)\n\t\t\t\treturn;\n\n\t\t\tfinalMaterial = new THREE.MeshPhongMaterial({\n\t\t\t\tside: THREE.FrontSide, map:getTexture(ft.filename, localReader, sharedTextures)\n\t\t\t}); \n\t\t\tif(nt) {\n\t\t\t\tvar normalMap = getTexture(nt.filename, localReader, sharedTextures);\n\t\t\t\tnormalMap.flipY = true;\n\t\t\t\tfinalMaterial.normalMap = normalMap;\n\t\t\t}\n\n\t\t\t\t\n\t\t\tfinalMaterial.textureFilename = ft.filename;\n\t\t\tif(grChunk.data.flags!=16460){\n\t\t\t\t//console.log(\"Setting alpha flag for \",grChunk.data.flags)\n\t\t\t\tfinalMaterial.alphaTest = 0.05;\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\n\t/// Fallback material is monocolored red\n\telse{\n\t\tfinalMaterial = new THREE.MeshBasicMaterial({\n\t\t\tside: THREE.FrontSide,\n\t\t\tcolor:0xff0000,\n\t\t\tshading: THREE.FlatShading}); \n\t}\n\n\t\n\tfinalMaterial.needsUpdate = true;\n\n\n\t/// Set material props\n\t/// disable for now in order for custom shaders not to fuck up\n\t\n\tif(material){\n\n\t\tvar alphaMask0 = 0x0001;// + 0x0100 + 0x0200;\n    \tvar alphaMask1 = 0x0010\n    \tvar alphaMask2 = 0x0100 + 0x0200;\n    \tvar alphaMask2b =  0x0200;\n\n\t\t\n\t\tvar grChunk = materialFile.getChunk(\"grmt\");\n\n\t\t//Enable alpha test for transparent flags\n    \tif( (\n    \t\t material.materialFlags & alphaMask0 ||\n    \t\t material.materialFlags & alphaMask1 ||\n    \t\t material.materialFlags & alphaMask2\n    \t\t) //&& solidColor != null\n\t\t){\n    \t\t//return;\n    \t\t//mesh.material.transparent = true;\n    \t\t//mesh.material.opacity = 2.0;\n\n    \t\t//var clr = solidColor;\n    \t\t//var propAlpha = 0;\n\n    \t\t///Backgroud color adds to alpha\n    \t\t//if( mesh.materialFlags == 2569  ){\n\n    \t\t/// This is rly just guesswork\n    \t\t/// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n    \t\t/// Same flags but some have alpha and some don't\n    \t\t//if( mesh.materialFlags & alphaMask2b  ){\n    \t\t//\tpropAlpha =  (clr[3] - 128)/128;\n    \t\t//\t//propAlpha = Math.max(0,propAlpha);\n    \t\t//}\n\n    \t\t//mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n    \t\t\n    \t}\n\n\n\t\t/// GRCHUNK -> DATA -> FLAGS\n\n\t\t///HAS LIGHT - TEX - ? - EMISSIVE16460\n\t\t///\n\t\t\n\t\t/// 56533 LOD FOR TOMBSTONE?\n\t\t\n\t\t//\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n\t\t//\t\n\t\t//\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n\t\t//\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n\t\t//\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n\t\t//\t\n\t\t//\t 8268\t\t\t0010 0000 0100 1100\t\n\t\t//\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n\t\t//\t 2380\t\t\t0000 1001 0100 1100\n\t\t//\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n\t\t//\t  332\t\t\t0000 0001 0100 1100\n\t\t//\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n\t\t//\t  \n\t\t//\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n\t\t//\t  \n\t\t//\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\t\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n\t\t//\t   \n\t\t//\t   \n\t\t//\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n\t\t//\t   \n\t\t//\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n\n\t\tvar lightMask = 8;\n\t\t\n\t\tvar knownFileFlags = [\n\t\t\t16460,\n\t\t\t16452,\n\t\t\t16448,\n\t\t\t8268,\n\t\t\t3392,\n\t\t\t2380,\n\t\t\t2368,\n\t\t\t332,\n\t\t\t324,\n\t\t\t320,\n\t\t\t76,\n\t\t\t68,\n\t\t\t64];\n\n\t\tif(knownFileFlags.indexOf(grChunk.data.flags)<0){\n\t\t\tT3D.Logger.log(\n\t\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\t\"unknown GR flag\",grChunk.data.flags\n\t\t\t);\n\t\t}\n\n\t\tif( !(grChunk.data.flags & lightMask) ){\n\t\t\t//debugger;\n\t\t\t//console.log(\"no light\");\n\t\t\tfinalMaterial =  new THREE.MeshBasicMaterial({\n\t\t\t\tside: THREE.FrontSide,\n\t\t\t\tmap: finalMaterial.map\n\t\t\t});\n\n\t\t}\n\t\t\n\t\tif(grChunk.data.flags!=16460){\n\t\t\tfinalMaterial.alphaTest = 0.05;\n\t\t}\n\n\n\t}/// End if material\n\t\n\n\treturn finalMaterial;\n\n}\n\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n * \n * @memberof MaterialUtils\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction getTexture(texURL, localReader, sharedTextures){\n\n\tvar finalTexture;\n\n\t/// Read texture from shared array of loaded textures\n\t/// or read it from URL and add to shared ones!\t\t\t\n\tif(texURL && sharedTextures[texURL]){\n\n\t\t/// Just read from already loaded textures.\n\t\tfinalTexture = sharedTextures[texURL];\n\n\t}\n\telse if(texURL){\n\n\t\t/// Load and add to shared array.\n\t\tfinalTexture = loadLocalTexture(localReader,texURL);\n\n\t\t/// Set standard texture functionality.\n\t\tfinalTexture.wrapT = THREE.RepeatWrapping;\n\t\tfinalTexture.wrapS = THREE.RepeatWrapping;\n\t\tfinalTexture.flipY = false;\n\n\t\tsharedTextures[texURL] = finalTexture;\n\t}\n\n\treturn finalTexture;\n}\n\n\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n * \n * @memberof MaterialUtils\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror){\n\t\n\tif(defaultColor === undefined){\n\t\tdefaultColor = Math.floor( 0xffffff * Math.random() )\n\t}\n\n\t/// Temporary texture that will be returned by the function.\n\t/// Color is randomized in order to differentiate different textures during loading.\n\tvar texture =  generateDataTexture(\n\t\t1, // Width\n\t\t1, // Height\n\t\tnew THREE.Color( defaultColor ) // Color\n\t);\n\n\t//Threejs r71 is using these settings by default, r72+ changed it\n\ttexture.minFilter = THREE.LinearMipMapLinearFilter;\n\ttexture.magFilter = THREE.LinearFilter;\n\ttexture.generateMipmaps = true;\n\ttexture.flipY = true;\n\n\t/// Only allow non-zero fileId, otherwise jsut return static texture\n\tif( parseInt(fileId) <= 0 ){\n\t\tif(onerror)\n\t\t\tonerror();\n\t\treturn texture;\n\t}\n\n\t/// Load file using LocalReader.\n\tlocalReader.loadTextureFile(fileId,\n\t\tfunction(inflatedData, dxtType, imageWidth, imageHeigth){\n\n\t\t\t/// Require infalted data to be returned.\n\t\t\tif(!inflatedData){\n\t\t\t\tif(onerror)\n\t\t\t\t\tonerror();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/// Create image using returned data.\n\t\t\tvar image = {\n\t\t\t\tdata   : new Uint8Array(inflatedData),\n\t\t\t\twidth  : imageWidth,\n\t\t\t\theight : imageHeigth\n\t\t\t};\n\n\t\t\t/// Use RGBA for all textures for now...\n\t\t\t/// TODO: don't use alpha for some formats!\n\t\t\ttexture.format = (dxtType==3 || dxtType==5 || true) ? THREE.RGBAFormat : THREE.RGBFormat;\n\n\t\t\t/// Update texture with the loaded image.\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t);\t\n\n\t/// Return texture with temporary content.\n\treturn texture;\n};\n\nmodule.exports = {\n\tbuildVS: buildVS,\n\tgenerateDataTexture: generateDataTexture,\n\tbuildPS: buildPS,\n\tgetUVMat: getUVMat,\n\tgetMaterial: getMaterial,\n\tloadLocalTexture: loadLocalTexture\n}","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst base32Max = Math.pow(2, 32);\n\n/**\n * Collection Math and sorting methods\n * @namespace MathUtils\n */\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n *\n * @memberof MathUtils\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nfunction f16(h) {\n    var s = (h & 0x8000) >> 15;\n    var e = (h & 0x7C00) >> 10;\n    var f = h & 0x03FF;\n\n    if (e == 0) {\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    } else if (e == 0x1F) {\n        return f ? NaN : ((s ? -1 : 1) * Infinity);\n    }\n\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\n}\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n * \n * @memberof MathUtils\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nfunction popcount(bits) {\n    var SK5 = 0x55555555,\n        SK3 = 0x33333333,\n        SKF0 = 0x0f0f0f0f,\n        SKFF = 0xff00ff;\n\n    bits -= (bits >> 1) & SK5;\n    bits = (bits & SK3) + ((bits >> 2) & SK3);\n    bits = (bits & SKF0) + ((bits >> 4) & SKF0);\n    bits += bits >> 8;\n\n    return (bits + (bits >> 15)) & 63;\n}\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to \n * the limit of the javascript Number maximum value.\n * \n * @memberof MathUtils\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nfunction arr32To64(arr) {\n    /// Re-read as uint64 (still little endian)\n    /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n    return base32Max * arr[1] + arr[0];\n}\n\n/**\n * Sorts an array and returns unique values only.\n * \n * @memberof MathUtils\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nfunction sort_unique(arr_in, comparator) {\n    var arr = Array.prototype.sort.call(arr_in, comparator);\n\n    var u = {},\n        a = [];\n    for (var i = 0, l = arr.length; i < l; ++i) {\n        if (u.hasOwnProperty(arr[i])) {\n            continue;\n        }\n        a.push(arr[i]);\n        u[arr[i]] = 1;\n    }\n\n    return a;\n}\n\n\nmodule.exports = {\n    f16: f16,\n    popcount: popcount,\n    arr32To64: arr32To64,\n    sort_unique: sort_unique\n};","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @namespace ParserUtils\n */\n\n/**\n * Collection of methods used for parsing complex data types from the .dat\n *\n * Most of these methods are only refered by the automatically generated script\n * AllFormats.js\n * \n */\n\nmodule.exports = {\n\n\t/**\n\t * Generates a function for reading an array using DataStream\n\t * \n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the items in the array.\n\t * @param  {Number} maxCount The maximum allowed length of the array.\n\t *                           Allows any length if left unspecified.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetArrayReader : function(structDef, maxCount){\n\t\treturn function(ds, struct){\n\t\t\tvar ret = [];\n\t\t\ttry{\n\n\t\t    \tvar arr_len = ds.readUint32();\n\t\t    \tvar offset = ds.readUint32(); \n\t\t\t\tif(offset == 0){\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tvar arr_ptr = ds.position -4 + offset;\n\t\t    \tvar pos = ds.position;\t   \n\n\t\t    \tif(maxCount && arr_len > maxCount){\n\t\t    \t\tthrow(\"Array length \"+arr_len+\" exceeded allowed maximum \" + maxCount);\n\t\t    \t}\n\n\t\t    \tvar pos = ds.position;   \t\n\t\t    \t\n\t    \t\n\t\t    \tds.seek( arr_ptr );\n\t\t    \tret = ds.readType (['[]',structDef,arr_len], struct);\n\t\t    \tds.seek(pos);\n\t    \t}\n\t    \tcatch(e){\n\t    \t\tconsole.warn(\"getArrayReader Failed loading array\", e);\n\t    \t\tconsole.warn(\"getArrayReader Failed loading array, structDef\", structDef);\n\t    \t}\n\t    \treturn ret;\n\t    }\n\t},\n\n\t/**\n\t * Generates a function for reading a refered array using DataStream\n\t * \n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the items in the array.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetRefArrayReader : function(structDef){\n\t\treturn function(ds, struct){\n\t    \t\n\t    \tvar ret_arr=[];\n\n\t    \t/// Read array of offsets\n\t    \tvar arr_len = ds.readUint32();\n\t\t    var arr_ptr = ds.position + ds.readUint32();\n\n\t    \tif(arr_len==0){\n\t    \t\treturn ret_arr;\n\t    \t}\n\n\t    \tvar orgPos = ds.position;\n\n\t    \t/// Go to pointer and read an array of offsets!\n\t    \tds.seek(arr_ptr);\n\t    \tvar offsets = ds.readInt32Array(arr_len);\t\n\n\n\t    \t//p_data is after having read array\n\t    \t//var pointer = p_data - 4;\n\t    \tvar pointer = orgPos -4;\n\n        \t//auto offset  = *reinterpret_cast<const int32*>(pointer);\n        \tds.seek(pointer);\n        \tvar offset = ds.readUint32(); /// this should be the same as arr_ptr\n        \t\n        \t//pointer     += offset;\n        \tpointer +=offset;\n\n\t    \tfor(var i=0;i<offsets.length;i++){\n\n\t    \t\t\n\t    \t\tif(offsets[i] != 0){\n\n\t    \t\t\tvar pos = pointer + i * 4 + offsets[i];\n\t\t    \t\tds.seek(pos);\n\n\t\t    \t\ttry{\n\t\t    \t\t\tret_arr.push(ds.readStruct(structDef));\t\n\t\t    \t\t}\n\t\t    \t\tcatch(e){\n\t\t    \t\t\t//debugger;\n\t\t    \t\t\tret_arr.push(null);\n\t\t    \t\t\tconsole.warn(\"getRefArrayReader could not find refered data at offset\",offsets[i] ,e);\n\t\t    \t\t}\n\n\t    \t\t}\n\t    \t\t\n\t    \t}/// End for each offset\n\n\t    \tds.seek(orgPos);\n\t    \treturn ret_arr;\n\n\n\t    }\n\t},\n\n\n\t/**\n\t * Generates a function for reading a 64bit initeger. For now just reads each\n\t * 32 bit integer and glues together as a string.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetQWordReader:function(){\n\t\tvar base32Max = 4294967296;\n\t\treturn function(ds, struct){\n\t\t\treturn ds.readUint32()+\"-\"+ds.readUint32();\n\n\t\t\tvar p0= ds.readUint32();\n\t\t\tvar p1= ds.readUint32();\n\t\t\treturn base32Max*p1 + p0;\n\t\t}\n\t\t\n\t},\n\t\n\t/**\n\t * Generates a function for reading a string of 8 bit chars.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetStringReader : function(){\n\t\treturn function(ds, struct){\n\t\t\tvar ptr = ds.position + ds.readUint32();\n\t    \tvar pos = ds.position;\t    \t\n\n\t    \t/// Go to pointer\n\t    \tds.seek( ptr );\n\n\t    \tvar ret = ds.readCString();\n\n\t\t\t/// Go back to where we were\n\t    \tds.seek( pos );\n\n\t    \treturn ret;\n\t    }\n\t},\n\n\t/**\n\t * Generates a function for reading a string of 16 bit chars.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetString16Reader : function(stringOffset){\n\t\treturn function(ds, struct){\n\t\t\tvar ptr = ds.position + ds.readUint32() + (stringOffset ? stringOffset : 0);\n\t    \tvar pos = ds.position;\t    \t\n\n\t    \t/// Go to pointer\n\t    \tds.seek( ptr );\n\n\t    \tvar ret = \"\";\n\t    \tvar num;\n\t    \twhile(ds.position+2<ds.byteLength && (num = ds.readUint16()) != 0 ){\n\t    \t\tret += String.fromCharCode(num);\n\t    \t}\n\t    \t//ds.readCString();\n\n\t\t\t/// Go back to where we were\n\t    \tds.seek( pos );\n\n\t    \treturn ret;\n\t    }\n\t},\n\n\n\t/**\n\t * Generates a function for reading a pointer.\n\t * \n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the item pointed to.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetPointerReader : function(structDef){\n\t\treturn function(ds, struct){\n\t\t\tvar offset = ds.readUint32(); \n\n\t\t\tif(offset == 0){\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tvar ptr = ds.position -4 + offset;\n\t    \tvar pos = ds.position;\t    \t\n\n\t    \t/// Go to pointer\n\t    \tds.seek( ptr );\n\t    \t\n\t    \tvar ret = ds.readStruct(structDef);\n\n\t\t\t/// Go back to where we were\n\t    \tds.seek( pos );\n\n\n\t    \treturn ret;\n\t    }\n\t},\n\n\t/**\n\t * Generates a function for reading a filename/file Id.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetFileNameReader : function(){\n\t\treturn function(ds, struct){\n\t\t\ttry{\n\t\t\t\tvar ptr = ds.position + ds.readUint32();\n\t    \t\tvar pos = ds.position;\t    \t\n\t    \t\n\t\t    \t/// Go to pointer\n\t\t    \tds.seek( ptr );\n\n\t\t    \tvar fileRef = ds.readStruct([\n\t\t    \t\t\"m_lowPart\", \"uint16\", //uint16 m_lowPart;\n\t\t\t\t    \"m_highPart\", \"uint16\", //uint16 m_highPart;\n\t\t\t\t    \"m_terminator\", \"uint16\",//uint16 m_terminator;\n\t\t\t\t]);\n\n\n\t\t\t\t/// Getting the file name...\n\t\t\t\t/// Both need to be >= than 256 (terminator is 0)\n\t\t\t\tvar ret = 0xFF00 * (fileRef.m_highPart - 0x100) + (fileRef.m_lowPart - 0x100) + 1;\n\t\t\t\t//var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\n\n\t\t\t\tif(ret<0){\n\t\t\t\t\tret = 0;\n\t\t\t\t\t//console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\n\t\t\t\t\t//debugger;\n\t\t\t\t}\n\n\t\t    \t/// Go back to where we were\n\t\t    \tds.seek( pos );\n\n\t\t    \treturn ret;\n\t    \t}\n\t    \tcatch(e){\n\t    \t\t/// Go back to where we were\n\t\t    \tds.seek( pos );\n\n\t\t    \treturn -1;\n\t    \t}\t    \t\n\t    }\n\t}\n}","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst MathUtils = require(\"./MathUtils\");\n\n//TODO: Remove this local cache!!\nlet matFiles = {};\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @property fvfFormat\n * @private\n * @type {Object}\n */\nlet fvfFormat = {\n\tPosition              : 0x00000001,   /**< 12 bytes. Position as three 32-bit floats in the order x, y, z. */\n\tWeights               : 0x00000002,   /**< 4 bytes. Contains bone weights. */\n    Group                 : 0x00000004,   /**< 4 bytes. Related to bone weights. */\n    Normal                : 0x00000008,   /**< 12 bytes. Normal as three 32-bit floats in the order x, y, z. */\n    Color                 : 0x00000010,   /**< 4 bytes. Vertex color. */\n    Tangent               : 0x00000020,   /**< 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */\n    Bitangent             : 0x00000040,   /**< 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */\n    TangentFrame          : 0x00000080,   /**< 12 bytes. */\n    UV32Mask              : 0x0000ff00,   /**< 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */\n    UV16Mask              : 0x00ff0000,   /**< 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */\n    Unknown1              : 0x01000000,   /**< 48 bytes. Unknown data. */\n    Unknown2              : 0x02000000,   /**< 4 bytes. Unknown data. */\n    Unknown3              : 0x04000000,   /**< 4 bytes. Unknown data. */\n    Unknown4              : 0x08000000,   /**< 16 bytes. Unknown data. */\n    PositionCompressed    : 0x10000000,   /**< 6 bytes. Position as three 16-bit floats in the order x, y, z. */\n    Unknown5              : 0x20000000,   /**< 12 bytes. Unknown data. **/\n};\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @namespace RenderUtils\n */\n\n\n\n/**\n * Creates a mesh representing a single plane.\n * \n * @memberof RenderUtils\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nfunction renderRect(rect, yPos, material, dy){\n\tvar dx = rect.x1 - rect.x2;\n\tvar dz = rect.y1 - rect.y2;\n\tif(!dy)\n\t\tdy = 1;\n\n\tvar cx = (rect.x1 + rect.x2)/2;\n\tvar cz = (rect.y1 + rect.y2)/2;\n\tvar cy = yPos;\n\n\tvar geometry = new THREE.BoxGeometry( dx, dy, dz );\n\n\n\tmaterial = material || new THREE.MeshBasicMaterial(\n\t\t{\n\t\t \tcolor: 0xff0000,\n\t\t\twireframe:true,\n\t\t}\n\t);\n\tvar plane = new THREE.Mesh( geometry, material );\n\tplane.overdraw = true;\n\t\n\tplane.position.x = cx;\n\tplane.position.y = cy;\n\tplane.position.z = cz;\n\n\treturn plane;\n};\n\n\n/**\n * Load image data into a THREE.Texture from a file within the GW2 .dat file using a LocalReader.\n *\n * @deprecated Please use the original function from MaterialUtils\n * @memberof RenderUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Number} fileId The fileId or baseId of the file to load image data from.\n * @param {Number} mapping What THREE mapping the returned texture will use, not implemented.\n * @param  {Array} defaultColor RGBA array of 4 integers. The default solid color of the mesh, should texture loading fail.\n * @param {Function} onerror Error callback, not implemented.\n * \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror){\n\tT3D.Logger.log(T3D.Logger.TYPE_WARNING, \"RenderUtils.loadLocalTexture is deprecated ! Please use the one from MaterialUtils.\");\n\treturn MaterialUtils.loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror);\n};\n\n/**\n * Returns a THREE representation of the data contained by a GW2 model file.\n * The data is read using a LocalReader reference into the GW2 .dat.\n *\n * @memberof RenderUtils \n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} chunk Model GEOM chunk.\n * @param {Object} modelDataChunk Model MODL chunk.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * \n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n */\nfunction renderGeomChunk(localReader, chunk, modelDataChunk, sharedTextures, showUnmaterialed){\n\n\tvar rawMeshes = chunk.data.meshes;\n\tvar meshes = [];\n\tvar mats = modelDataChunk.data.permutations[0].materials;\n\t\n\trawMeshes.forEach(function(rawMesh){\n\n\t\tvar rawGeom = rawMesh.geometry;\n\t\tvar fvf = rawGeom.verts.mesh.fvf;//rawGeom.fvf;\n\n\t\tvar numVerts = rawGeom.verts.vertexCount;//rawGeom.vertexCount;\n\t\t\n\t\tvar rawVerts = rawGeom.verts.mesh.vertices;//rawGeom.vertices\n\n\t\tvar indices = rawGeom.indices.indices;\n\n\t\tvar geom = new THREE.BufferGeometry();\n\n\t\tvar vertDS =  new DataStream(rawVerts.buffer);\n\n\t\t//Dirty step length for now:\n\t\tvar stride = rawVerts.length / numVerts;\n\n\t\t//Each vertex\n\t\t//DO UV as well\n\t\tvar vertices = new Float32Array( numVerts * 3 );\n\t\tvar tangents = null; \n\t\tvar normals = null;\n\t\tvar uvs = []; \n\t\t\n\n\t\t/// Calculate the distance to the first pair of UV data from the\n\t\t/// start of the vertex entry\n\t\t/// \n\t\tvar distToNormals = \n\t\t\t!!(fvf & fvfFormat.Position) \t\t* 12 +\n\t\t\t!!(fvf & fvfFormat.Weights) \t\t*  4 +\n\t\t\t!!(fvf & fvfFormat.Group) \t\t\t*  4 ;\n\n\t\tvar distToTangent = \n\t\t\tdistToNormals\t\t\t\t\t\t\t +\n\t\t\t!!(fvf & fvfFormat.Normal) \t\t\t* 12 +\n\t\t\t!!(fvf & fvfFormat.Color) \t\t\t*  4;\n\n\t\tvar distToBittangent = \n\t\t\tdistToTangent\t\t\t\t\t\t +\n\t\t\t!!(fvf & fvfFormat.Tangent) \t\t* 12;\n\n\t\tvar distToTangentFrame = distToBittangent\t +\n\t\t\t!!(fvf & fvfFormat.Bitangent) \t\t* 12;\n\n\t\tvar distToUV = \n\t\t\tdistToTangentFrame\t\t\t\t\t\t +\n\t\t\t!!(fvf & fvfFormat.TangentFrame) \t* 12;\n\n\t\t/// Check if the UV is 32 bit float or 16 bit float.\n\t\tvar uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n\t\tvar uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n\t\tvar isUV32 = !!uv32Flag;\n\t\tvar hasUV = !!uv16Flag || !!uv32Flag;\n\t\t\n\t\t/// Popcount (count the number of binary 1's) in the UV flag\n\t\t/// to get the number of UV pairs used in this vertex format.\n\t\tvar masked = isUV32 ? uv32Flag : uv16Flag;\n\t\tvar numUV = MathUtils.popcount(masked);\n\n\t\tnumUV = Math.min(numUV,1.0);\n\n\n\t\t/// Create typed UV arrays\n\t\tif(hasUV){\n\t\t\tfor(var i=0; i<numUV; i++){\n\t\t\t\tuvs[i] = new Float32Array( numVerts * 2 );\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t\n\t\n\t\tif( !!(fvf & fvfFormat.Normal) ){\n\t\t\t\n\t\t\t//console.log(\"HAS Normal\");\n\n\t\t}\n\t\n\t\tif( !!(fvf & fvfFormat.Tangent) ){\n\t\t\t\n\t\t\t//console.log(\"HAS Tangent\");\n\n\t\t}\n\n\t\tif( !!(fvf & fvfFormat.Bitangent) ){\n\t\t\t\n\t\t\t//console.log(\"HAS Bitangent\");\n\n\t\t}\n\t\tif( !!(fvf & fvfFormat.TangentFrame) ){\n\t\t\t\n\t\t\t//console.log(\"HAS TangentFrame\");\n\n\t\t}\n\n\t\t/// Read data from each vertex data entry\n\t\tfor(var i=0; i<numVerts; i++){\n\n\t\t\t/// Go to vertex memory position\n\t\t\tvertDS.seek(i*stride);\n\n\t\t\t/// Read position data\n\t\t\t/// (we just hope all meshes has 32 bit position...)\n\t\t\tvar x = vertDS.readFloat32();\n\t\t\tvar z = vertDS.readFloat32();\n\t\t\tvar y = vertDS.readFloat32();\n\n\t\t\t/// Write position data, transformed to Tyria3D coordinate system.\n\t\t\tvertices[i*3 + 0] =  x ;//- c.x;\n\t\t\tvertices[i*3 + 1] = -y ;//+ c.y;\n\t\t\tvertices[i*3 + 2] = -z ;//+ c.z;\n\n\t\t\t/// Read data at UV position\n\t\t\tif(hasUV){\n\t\t\t\t\n\t\t\t\tfor(var uvIdx=0; uvIdx<numUV; uvIdx++){\n\n\t\t\t\t\tvertDS.seek(\n\t\t\t\t\t\ti*stride + \n\t\t\t\t\t\tdistToUV + \n\t\t\t\t\t\tuvIdx*(isUV32 ? 8 : 4)\n\t\t\t\t\t);\n\n\t\t\t\t\t/// Add one UV pair:\n\t\t\t\n\t\t\t\t\tvar u,v;\n\t\t\t\t\tif(isUV32){\n\t\t\t\t\t\tu = vertDS.readUint32();\n\t\t\t\t\t\tv = vertDS.readUint32();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tu = MathUtils.f16(vertDS.readUint16());\n\t\t\t\t\t\tv = MathUtils.f16(vertDS.readUint16());\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/// Push to correct UV array\n\t\t\t\t\tuvs[uvIdx][i*2 + 0] = u;\n\t\t\t\t\tuvs[uvIdx][i*2 + 1] = v;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t} /// End if has UV\n\t\t\t\t\n\n\t\t\t\n\n\t\t} /// End each vertex\n\n\t\t/// Each face descripbed in indices\n\t\tvar faces = new Uint16Array( indices.length );\t\t\n\t\tfor(var i=0; i<indices.length; i+=3){\n\n\t\t\t// This is ONE face\n\t\t\tfaces[i + 0] = indices[i + 2];\n\t\t\tfaces[i + 1] = indices[i + 1];\n\t\t\tfaces[i + 2] = indices[i + 0];\n\n\t\t}// End each index aka \"face\"\n\n\n\t\t/// Add position, index and uv props to buffered geometry\n\t\tgeom.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\t//geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n\t\tgeom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n\t\tif(normals){\n\t\t\tconsole.log(\"adding normals\");\n\t\t\tgeom.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\t\tgeom.normalizeNormals();\n\t\t\tgeom.normalsNeedUpdate = true;\n\t\t}\n\t\telse{\n\t\t\t/// Calculate normals\n\t\t\tgeom.computeVertexNormals();\n\t\t}\n\n\t\t\n\t\tif(hasUV){\n\n\t\t\tfor(var uvIdx=0; uvIdx<numUV; uvIdx++){\n\n\t\t\t\t/// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n\t\t\t\tvar uvName = \"uv\" + ( uvIdx > 0 ? uvIdx+1 : \"\" );\n\t\t\t\t\n\t\t\t\t/// Set \"custom\" attribute uvN\n\t\t\t\tgeom.addAttribute( uvName, new THREE.BufferAttribute( uvs[uvIdx], 2 ) );\n\n\t\t\t\t/// Flag for update\n\t\t\t\tgeom.attributes[uvName].needsUpdate = true;\t\n\t\t\t}\n\t\t\t\n\n\t\t\t/// Not needed anymore?\n\t\t\tgeom.uvsNeedUpdate = true;\t\n\t\t}\n\t\t\n\n\t\t/// Tell geometry to update its UVs and buffers\n\t\tgeom.buffersNeedUpdate = true;\n\n\t\t/// DONE READING VERTEX DATA\n\t\t\n\n\t\t/// Get material used for this mesh\n\t\tvar matIdx = rawMesh.materialIndex;\n\t\tvar mat = mats[matIdx];\n\t\tvar materialFile = null\n\n\t\tif(mat && matFiles[mat.filename]){\n\t\t\tmaterialFile = matFiles[mat.filename];\t\t\t\n\t\t}\n\n\t\tvar finalMaterial =  MaterialUtils.getMaterial(mat, materialFile, localReader, sharedTextures);\t\n\t\n\n\t\t/// IF we could not find a material abort OR use a wireframe placeholder.\n\t\tif(!finalMaterial){\n\t\t\tif(showUnmaterialed){\n\t\t\t\tfinalMaterial = new THREE.MeshLambertMaterial(\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor: 0x5bb1e8,\n\t\t\t\t\t\twireframe:false,\n\t\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn;\t\n\t\t\t}\t\t\t\n\t\t}\n\n\t\t\n\n\t\t/// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n\t\tvar finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n\t\t\n\t\t/// Set material info on the returned mesh\n\t\tif(mat){\n\t\t\tfinalMesh.materialFlags = mat.materialFlags;\n\t\t\tfinalMesh.materialFilename = mat.filename;\n\t\t}\n\n\t\tfinalMesh.materialName = rawMesh.materialName;\n\n\t\t/// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n\t\t/// Set lod info on the returned mesh\n\t\tfinalMesh.numLods = rawMesh.geometry.lods.length;\n\t\tfinalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n\t\t/// Set flag and UV info on the returned mehs\n\t\tfinalMesh.flags = rawMesh.flags;\n\t\tfinalMesh.numUV = numUV;\n\n\t\t/// Add mesh to returned Array\n\t\tmeshes.push( finalMesh );\n\n\t});/// End rawMeshes forEach\n\t\n\treturn meshes;\t\n};\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n * \n * @memberof RenderUtils\n * @async\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n \n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n * \n * The second argument is the bounding spehere of this model file.\n * \n */\n\nfunction loadMeshFromModelFile(filename, solidColor, localReader, sharedTextures, showUnmaterialed, callback){\n\n\t//Short handles prop attributes\n\tvar finalMeshes = [];\n\n\t///Load file\n\tlocalReader.loadFile(filename,function(inflatedData){\n\t\ttry{\n\t\t\tif(!inflatedData){\n\t\t\t\tthrow \"Could not find MFT entry for \"+filename;\n\t\t\t}\n\n\t\t\tvar ds = new DataStream(inflatedData);\n\n\t\t\tvar modelFile = new GW2File(ds,0);\n\n\t\t\t//MODL for materials -> textures\n\t\t\tvar modelDataChunk = modelFile.getChunk(\"modl\");\n\t\t    \n\t\t    //GEOM for geometry\n\t\t    var geometryDataChunk = modelFile.getChunk(\"geom\");\n\n\n\t\t    /// Hacky fix for not being able to adjust for position\n\t\t    var boundingSphere = modelDataChunk.data.boundingSphere;\n\t\t    var bsc = boundingSphere.center;\n\t\t    boundingSphere.radius+= Math.sqrt( bsc[0]*bsc[0] + Math.sqrt(bsc[1]*bsc[1] + bsc[2]*bsc[2]) );\n\n\t\t    /// Load all material files\n\t\t    var allMats = modelDataChunk.data.permutations[0].materials;\n\n\t\t    function loadMaterialIndex(mIdx, matCallback){\n\t\t    \t\n\t\t    \tif(mIdx>=allMats.length){\n\t\t    \t\t\n\t\t    \t\tmatCallback();\n\t\t    \t\treturn;\n\t\t    \t}\n\n\t\t    \tvar mat = allMats[mIdx];\n\n\t\t    \t/// Skip if file is loaded\n\t\t    \tif(matFiles[mat.filename]){\n\t\t    \t\tloadMaterialIndex(mIdx+1,matCallback);\n\t\t    \t\treturn;\n\t\t\t\t}\t\t\n\n\t\t\t\tlocalReader.loadFile(mat.filename,\n\t\t\t\t\tfunction(inflatedData){\n\t\t\t\t\t\tif(inflatedData){\n\t\t\t\t\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\t\t\t\t\tvar materialFile = new GW2File(ds,0);\n\t\t\t\t\t\t\tmatFiles[mat.filename] = materialFile;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tloadMaterialIndex(mIdx+1,matCallback);\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t);\n\t\t    }\n\n\n\n\t\t    loadMaterialIndex(0, function(){\n\n\t\t    \t/// Create meshes\n\t\t\t    var meshes = renderGeomChunk(localReader, geometryDataChunk, modelDataChunk, sharedTextures, showUnmaterialed);\t\t\t    \n\n\t\t\t    // Build mesh group\n\t\t\t    meshes.forEach(function(mesh){\n\t\t\t    \t\n\t\t\t    \t/// Material flags\n\t\t\t    \tvar knownflags = [\n\n\t\t\t    \t\t/*\n\t\t\t\t\t\t\t1-5\n\t\t\t\t\t\t\tHas Tex?\tIDK\t\t\tLight?\t\tAlpha?\n\n\t\t\t\t\t\t\t5-8\n\t\t\t\t\t\t\t0\t\t\t0\t \t\tIDK\t\t \tWater?\n\n\t\t\t\t\t\t\t9-12\n\t\t\t\t\t\t\tHas Tex?\t0\t\t\tAlpha?\t\tAlpha?\n\n\t\t\t\t\t\t\t13\n\t\t\t\t\t\t\tIDK KEV\n\t\t\t    \t\t*/\n\n\t\t\t    \t\t0,\t\t\t//0 0000 0000 0000\t\tGround / Wall splashes\n\t\t\t    \t\t8,\t\t\t//0 0000 0000 1000\t\tBroken Khylo roof DDS\n\t\t\t    \t\t9,\t\t\t//0 0000 0000 1001\t\tTree leaves\n\n\t\t\t    \t\t520,\t\t//0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\t\t\t    \t\t\n\n\t\t\t    \t\t2056,\t\t//0 1000 0000 1000\t\tSolid objects, also broken animations\n\n\t\t\t    \t\t///Solids here are unhappy, or are they? could be animations etc\n\t\t\t    \t\t2057,\t\t//0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n\t\t\t    \t\t2060,\t\t//0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n\t\t\t    \t\t2061,\t\t//0 1000 0000 1101\t\tA few bushes, two paintings\n\t\t\t    \t\t\n\t\t\t    \t\t\n\t\t\t    \t\t2312,\t\t//0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n\t\t\t    \t\t2316,\t\t//0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n\t\t\t    \t\t// Number 10\n\t\t\t    \t\t2568,\t\t//0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n\t\t\t    \t\t//Number 11\n\t\t\t    \t\t2569,\t\t//0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n\t\t\t    \t\t2572,\t\t//0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n\t\t\t    \t\t2573,\t\t//0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n\t\t\t    \t\t2584,\t\t//0 1010 0001 1000\t\tFountain Well water\n\n\t\t\t    \t\t2824,\t\t//0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n\t\t\t    \t\t2828,\t\t//0 1011 0000 1100\t\tA few fence post (non solids)\n\t\t\t    \t\t2840,\t\t//0 1011 0001 1000\t\tFountain running water + pipe water\n\n\t\t\t    \t\t4617,\t\t//1 0010 0000 1001\t\tFound nothing\n\t\t\t    \t\t6664\t\t//1 1010 0000 1000\t\tTwo groups of solid boxes\n\t\t\t    \t];\n\n\t\t\t    \tvar alphaMask0 = 0x0001;// + 0x0100 + 0x0200;\n\t\t\t    \tvar alphaMask1 = 0x0010\n\t\t\t    \tvar alphaMask2 = 0x0100 + 0x0200;\n\t\t\t    \tvar alphaMask2b =  0x0200;\n\n\t\t\t    \tvar texMask = 0x8 + 0x0800;\n\n\n\t\t\t    \tif(knownflags.indexOf(mesh.materialFlags)!==11){\n\t\t\t    \t\t//return;\n\t\t\t    \t}\n\n\t\t\t    \t// No smoke etc\n\t\t\t    \tif( mesh.materialFlags == 520 ){\n\t\t\t    \t\t//return;\n\t\t\t    \t}\n\n\t\t\t    \t//Must have texture\n\t\t\t    \tif(!showUnmaterialed && !(mesh.materialFlags & texMask) ){\n\t\t\t    \t\treturn;\n\t\t\t    \t}\n\n\t\t\t\t\t//NO lods\n\t\t\t    \tif(mesh.flags == 4 || mesh.flags == 1 || mesh.flags == 0){\n\t\t\t    \t\t//return;\n\t\t\t    \t}\n\n\t\t\t\t\t//Add to final colection\n\t\t\t\t\tfinalMeshes.push(mesh);\n\n\t\t\t    });/// END FOR EACH meshes\n\n\t\t\t\tcallback(finalMeshes, boundingSphere);\n\n\t\t\t    \n\t\t    });/// END LOAD MATERIALS CALLBACK\n\n\n\t\t}\n\t    catch(e){\n\t    \tconsole.warn(\"Failed rendering model \"+filename,e);\n\t    \tvar mesh = new THREE.Mesh( new THREE.BoxGeometry( 200, 2000, 200 ), new THREE.MeshNormalMaterial() );\n\t    \tmesh.flags = 4;\n\t    \tmesh.materialFlags = 2056;\n\t    \tmesh.lodOverride = [1000000,1000000];\n\t    \tfinalMeshes.push(mesh);\n\n\t    \t/// Send the final meshes to callback function\n\t    \tcallback(finalMeshes);\n\t    }\n\t\t    \n\t});/// END FILE LOADED CALLBACK FUNCTION\n};\n\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n * \n * @memberof RenderUtils\n * @async\n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n * \n * The third argument is the bounding spehere of this model file.\n */\nfunction getMeshesForFilename(filename, color, localReader, sharedMeshes, sharedTextures, showUnmaterialed, callback){\n\n\t/// If this file has already been loaded, just return a reference to the meshes.\n\t/// isCached will be set to true to inform the caller the meshes will probably\n\t/// have to be cloned in some way.\n\tif( sharedMeshes[filename] ){\n\t\tcallback(sharedMeshes[filename].meshes, true, sharedMeshes[filename].boundingSphere)\n\t}\n\n\t/// If this file has never been loaded, load it using loadMeshFromModelFile\n\t/// the resulting mesh array will be cached within this model's scope.\n\telse{\n\n\t\tloadMeshFromModelFile(filename, color, localReader, sharedTextures, showUnmaterialed, function(meshes, boundingSphere){\n\n\t\t\t/// Cache result if any.\n\t\t\tif(meshes){\n\t\t\t\tsharedMeshes[filename] ={\n\t\t\t\t\tmeshes : meshes,\n\t\t\t\t\tboundingSphere : boundingSphere\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// Allways fire callback.\n\t\t\tcallback(meshes, false, boundingSphere);\n\n\t\t});\n\t}\n}\n\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n * \n * @memberof RenderUtils\n * @async\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nfunction getFilesUsedByModel(filename, localReader, callback){\n\tvar fileIds = [filename];\n\n\t///Load model file\n\tlocalReader.loadFile(filename,function(inflatedData){\n\t\t\n\t\ttry{\n\t\t\tif(!inflatedData){\n\t\t\t\tthrow \"Could not find MFT entry for \"+filename;\n\t\t\t}\n\n\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\tvar modelFile = new GW2File(ds,0);\n\n\t\t\t//MODL for materials -> textures\n\t\t\tvar modelDataChunk = modelFile.getChunk(\"modl\");\n\n\t\t\t/// Get materials used by model\n\t\t\tvar mats = modelDataChunk.data.permutations[0].materials;\n\n\t\t\t/// Add each material file AND referenced TEXTURES\n\t\t\tmats.forEach(function(mat){\n\n\t\t\t\t/// Add material file id\n\t\t\t\tvar matFileName = mat.filename;\n\t\t\t\tfileIds.push(matFileName);\n\n\t\t\t\t/// Add each texture file id\n\t\t\t\tmat.textures.forEach(function(tex){\n\t\t\t\t\tfileIds.push(tex.filename);\n\t\t\t\t})\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t}\n\t\tcatch(e){\n\t\t\tconsole.warn(\"Could not export any data\",e);\n\t\t}\n\n\t\tcallback(fileIds);\n\t});\n\n}\n\nmodule.exports = {\n\trenderRect: renderRect,\n\tloadLocalTexture: loadLocalTexture,\n\trenderGeomChunk: renderGeomChunk,\n\tloadMeshFromModelFile: loadMeshFromModelFile,\n\tgetMeshesForFilename: getMeshesForFilename,\n\tgetFilesUsedByModel: getFilesUsedByModel\n};","/*\nCopyright © Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n    ///TODO: port fog from in-engine\n\n    getFragmentShader: function(){\n        return [\n            \"uniform vec2 uvScale;\",\n            \"uniform vec2 offset;\",\n            \"uniform sampler2D texturePicker;\",\n            \"uniform sampler2D texturePicker2;\",\n            \"uniform sampler2D texture1;\",\n            \"uniform sampler2D texture2;\",\n            \"uniform sampler2D texture3;\",\n            \"uniform sampler2D texture4;\",\n    \n            THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n    \n            \"varying vec2 vUv;\",\n            \"varying vec3 vecNormal;\",\n    \n            \"vec3 blend(\",\n                    \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n                    \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n            \"{\",\n                \"float depth = 2.0;\",\n                \"float alphaMult = 1.0;\",\n                \"float alphaAdd  = 0.0;\",\n                \"a1 *= 4.0;\",\n                \"a2 *= 4.0;\",\n                \"a3 *= 4.0;\",\n                \"a4 *= 4.0;\",\n                \"a1 =  a1+(1.5+texture1.a);\",\n                \"a2 =  a2+(1.5+texture2.a);\",\n                \"a3 =  a3+(1.5+texture3.a);\",\n                \"a4 =  a4+(1.5+texture4.a);\",\n                \"float ma = max(a1,a2);\",\n                \"ma = max(ma,a3);\",\n                \"ma = max(ma,a4);\",\n                \"ma -= depth;\",\n                \"float b1 = max(a1 - ma, 0.0);\",\n                \"float b2 = max(a2 - ma, 0.0);\",\n                \"float b3 = max(a3 - ma, 0.0);\",\n                \"float b4 = max(a4 - ma, 0.0);\",\n                \"return (\",\n                    \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n                    \"texture3.rgb * b3 + texture4.rgb * b4 \",\n                \") / (b1 + b2 + b3 + b4);\",\n            \"}\",\n    \n            \"void main( void ) {\",\n                \"vec2 position = vUv*uvScale;\",\n                \"float edge = 1.0/1024.0;\",\n                \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n                \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n                \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n                \"vec4 composite = tp1;\",\n                \"vec4 t1 = texture2D( texture1, position );\",\n                \"vec4 t2 = texture2D( texture2, position );\",\n                \"vec4 t3 = texture2D( texture3, position );\",\n                \"vec4 t4 = texture2D( texture4, position );\",\n                \"vec3 color = blend(\",\n                    \"t1, tp1.a,\",\n                    \"t2, tp1.b,\",\n                    \"t3, tp1.g,\",\n                    \"t4, tp1.r\",\n                \");\",\n                \"color *= 0.5+tp2.r;\",\n                \"gl_FragColor = vec4(color,1.0);\",\n                THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n            \"}\"\n    \n        ].join( \"\\n\" );\n    },\n    getVertexShader : function(){\n        return [\n            \"varying vec2 vUv;\",\n            \"varying vec3 vecNormal;\",\n            THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n            \"void main()\",\n            \"{\",\n\n                \"vUv =  uv;\",\n                \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n                \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n                \"gl_Position = projectionMatrix * mvPosition;\",\n                THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n            \"}\"\n        ].join( \"\\n\" );\n    }\n}"]}